---
title: Linux的启动
mathjax: false
date: 2020-02-29 16:59:23
tags:
- 嵌入式搬砖手册
categories:
- 学习
- 嵌入式
---
简单叙述一下Linux的启动流程。
<!--more-->
总共是三个步骤：
```mermaid
graph LR
A[Bootloader]-->B[kernal]
B --> C[rootfs]
```
在PC和嵌入式中，Linux的启动是不太一样的，一般在PC中都是使用BIOS引导硬件启动之后交给系统，但是在嵌入式中，则是使用bootloader进行硬件的初始话之后引导系统内核，再之后挂载根文件系统。区别在于BIOS不具备直接向内核传参的功能，bootloader的功能则相对更加强大一些。  
# 嵌入式系统的构成
{%asset_img 20130911140900046.png%}  
上图是一个嵌入式Linux系统的典型结构，划分成了4个区：

1. Bootloader区存放的是Bootloader，它负责嵌入式系统最初的硬件初始化、驱动和内核加载。
2. 参数区不是必须的，通常存放了一些系统参数，并且通常这个区是没有文件系统，参数以原始数据的格式来存放。
3. 内核镜像区存放的Linux内核压缩镜像，它被解压后运行于内存，作为嵌入式设备的Linux操作系统。
4. 文件系统区存放经过压缩的文件系统，它会被Linux内核解压并挂载，并作为各种应用程序、文件的主要载体。

下面来讲解一下整个Linux的启动流程。  
# UBoot
一块板子上电肯定是要先初始化硬件的，之后再引导内核、挂载文件系统。而初始化硬件这一步一般都是由bootloader实现的。  
而最常用的bootloader就是UBoot。UBoot本质上就是一个挂载系统之前的裸机程序。  
U-Boot，全称 Universal Boot Loader，是遵循GPL条款的开源项目，U-Boot是 从FADSROM、8xxROM、PPCBOOT逐步发展演化而来的。U-Boot发展至今，已经可以 实现非常多的功能，在操作系统方面，它不仅支持嵌入式Linux系统的引导，还支持NetBSD, VxWorks, QNX, RTEMS, ARTOS, LynxOS, Android等嵌入式操作系统的引导。在CPU架构方面 ，U-Boot支持PowerPC、MIPS、x86、ARM、NIOS、XScale等诸多常用系列的处 理器。U-Boot的主要作用是用来启动操作系统内核，它分为两个阶段，即boot + loader，boot阶段启动系统，初始化硬件设备，建立内存空间映射图，将系统的软硬件带到一个合适的状态，loader阶段将操作系统内核文件加载至内存，之后跳转到内核所在地址运行。  

U-Boot本身非常强大，包含了像烧写模式--如果在上电的时候进行操作可以在烧写模式下烧写系统，直接引导模式--直接加载系统，还有一些校验系统镜像完整性之类的功能。  

其boot和loader阶段的功能具体来讲就是下边几个阶段：  
boot：
1. 硬件设备初始化。
2. 加载U-Boot第二阶段代码到RAM空间。
3. 设置好栈。
4. 跳转到第二阶段代码入口。  

loader：
1. 初始化本阶段使用的硬件设备。
2. 检测系统内存映射。
3. 将内核从存储区域（Flash、SD Card、eMMC）读取到RAM中。
4. 为内核设置启动参数。
5. 调用内核。

# Kernel
## Linux内核
Kernel即是Linux内核，Linux内核采用宏内核架构，即Linux大部分功能都 会在内核中实现，如外设的内核驱动、进程管理、内存管理、设备管理、文件管理以及网络管 理等功能，它们是运行在内核空间中；除 此之外还有一种与宏内核相反的内核架构——微内核（没错，就是那个沸腾的鸿蒙大力鼓吹的内核架构），它仅仅是将内核的基本功 能放入内核中 ，如进程管理、进程调度等，而其他的设备管理、文件管理等功能都放在内核空间之外，这种微内核的架构有很优越的扩展性，它 将系统分为各个小的功能模块，把设计难度大大降低。  
而宏内核的设计架构则没有非常好的扩展性，但Linux在发展的过程中，很早就引入了内核模块（Loadable Kernel Module，LKM）这一机制，弥补了这一不足之处，内核模块全称为动态可加载内核模块，就是在内核运行时可以动态加载一组目标代码来实现某些特定的 功能，在这过程中不需要重新编译内核就可以实现动态扩展。模块是具有独立功能 的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核 的一部分在内核空间运行，这与运行在用户空间的进程是不同的。模块通常由一组 函数和数据结构组成，用来实现一种文件系统、一个驱动程序或其他内核上层的功能。  
### 内核驱动Kernal driver
我们经常提的Linux设备驱动就属于内核的一部分，由于UBoot不能很大，所以在UBoot工作的阶段只会初始化必要的资源，多数外设的驱动需要放在内核启动的阶段进行加载，Linux内核驱动的一个模块可以以两种方式被编译和加载：
1. 直接编译进Linux内核，随同Linux启动时加载。
2. 编译成一个可加载和删除的模块。  

这就是上边所说的LKM机制。  
驱动程序向内核添加了一些函数，是内核的一部分。例如Open(), Release(), Read(), Write()。这些函数由内核在适当的时候来调用，可以用来完成硬件访问等操作。驱动程序占kernel源代码超过50%。  

内核中printk()函数的设计目的并不是为了和用户交流，它实际上是内核的一种日志机制，用来记录下日志信息或者给出警告提示。如果syslogd 和klogd 守护进程在运行的话，则不管是否向控制台输出，消息都会被追加进/var/log/messages 文件。klogd只处理内核消息，syslogd 处理其他系统消息，比如应用程序。  

## Linux系统的组成
{%asset_img imagec004.jpeg %}  
### 文件管理子系统
在Linux系统中有一个重要的概念：一切皆文件，它把一切资源都看作是文件，包括硬件设备，通常称为设备文件。Linux的文件管理子系统主要实现了虚拟文件系统（Virtual File System，VFS），虚拟文件系统屏蔽了各种硬件上的差异以及具体实现的细节，为所有的硬件设备提供统一的接口，这样子也就实现了设备无关性，同时文件管理系统还为应用层提供统一的API接口。  
总的来说，Linux 的文件系统体系结构是对一个对复杂系统进行了抽象化，通 过使用一组通用的 API 函数，Linux 可以在许多种存储设备上支持多种文件系统，如NTFS、EXT2、EXT3、EXT4 、FAT等等；而用户空间包含一些应用程序和 GNU C 库（glibc），它们使用的API接口是由系统调用层提供（如打开、读、写和关闭等），其框架如下图所示。  
{%asset_img imagec008.png%}
### 设备子系统
设备子系统又被称之为设备驱动，由于嵌入式设备多种多样，所以内核选择了一种抽象的方式去描述设备，同时提供了各种内核驱动框架。  
系统调用层是Linux内核与应用程序之间的接口，而设备驱动则是Linux内核与硬件之间的接口，设备驱动程序为应用程序屏蔽了硬件的细节，这样在应用程序看来，硬件设备只是一个设备文件，应用程序可以象操作普通文件一样对硬件设备进行操作（打开、读、写和关闭）。设备驱动程序是内核的一部分，它主要完成以下的功能：

1. 对设备初始化和释放
2. 把数据从内核传送到硬件和从硬件读取数据
3. 读取应用程序传送给设备文件的数据和回送应用程序请求的数据
4. 检测和处理设备出现的错误

Linux在发展的时候就根据设备的共性将设备分层3大类，分别为：

- 字符设备
- 块设备
- 网络设备
  
先说说网络设备，它其实就是网络子系统中描述的网络设备层，它其实也是一个抽象，统一描述了不同的网卡设备，如WIFI、以太网等。因为网络设备存在协议栈（协议族），它涉及了网络层协议，所以Linux将网络设备单独分层一类设备，网络设备的传输速率通常是很高的。  

字符设备是以字节为单位传输的IO设备，可以提供连续的数据流，应用程 序可以顺序读取，通常不支持随机存取。这种字符传输的效率通常是比较低的，如鼠标、键盘、串口等都是字符设备，也是一种比较常见的设备。  

块设备是以块为单位进行传输的设备，应用程序可以随机访问块设备中的数据，程序可以指定读取数据的位置。我们的磁盘就是一种常见的块设备，应用程序可以寻址磁盘上的任何位置，并在这个位置读取数据。不过需要注意的是，块设备读取的数据只能以块为单位的倍数进行（通常是512Byte的整数倍），而不能与字符设备一样以字节为单位读取，因此通常来说块设备的传输速度是比较高的。  
{%asset_img imagec010.png%}  
# 根文件系统
此处讲解的文件系统是根文件系统（rootfs），它是linux在初始化时 加载的第一个文件系统，和文件管理子系统小节所说的文件系统不同，这两个是不同的概念。根文件系统包括根目录和真实文件系统，根文件系统之所以在前面加一个“根”，说明它是加载其它文件系统的“根”，如果没有这个“根”的 话，其它的文件系统也就没有办法进行加载的。因为它包含系统引导和使 其他文件系统得以挂载（mount）所必要的文件。根文件系统包函Linux启动时 所必须的目录和关键性的文件，例如Linux启动时必要的初始化文件，它在init目录下，此 外根文件系统中还包括了许多的应用程序bin目录等，任何包括这些Linux 系统启动所必须的文件都可以成为根文件系统。

在Linux内核启动的初始阶段，首先内核会初始化一个基于内存的文件系 统，如initramfs，initrd等，然后以只读的方式去加载根文件系统（load rootfs），读取并 且运行/sbin/init初始化文件，根据/etc/inittab配置文件完成系统的初始化工作（提示：/sbin/init是 一个二进制可执行文件，为系统的初始化程序，而/etc/inittab是它的配置文件），在初 始化的过程中，还会以读写的方式重新挂载根文件系统，在系统启动后，根文件系统就可用于存储数据了，存在根文件系统是Linux启动时的必要条件。

Linux中的文件系统多种多样，同时在Linux中一切皆是文件，普通文件、目录、字符 设备、块设备、套接字等都以文件方式被抽象化；且它们需要向上层提供统一的操作接口。虚拟文 件系统VFS就是Linux内核中的一个软件层，向上给用户空间程序提供文件系统操作接口；向下允许不同的文件系统共存，所以，所有实际文件系统都必须实现VFS的结构封装。因为无论是访问设备还是需要通过文件系统来访问它的挂载点。
