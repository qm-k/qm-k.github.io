<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>URDF的创建和使用</title>
      <link href="/2020/03/22/URDF%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/03/22/URDF%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>ROS中仿真一般使用URDF模型来仿真，它可以直接通过写脚本的方式实现模型的构建，详情可以看wiki，但是这种方式首先建模不精细，其次过程太痛苦了，如果想要简单一点的话我们可以通过想SW或者matlab这样的软件直接导出模型使用，导出的URDF文件可以在Rviz、gazebo还有V-rep等仿真器里直接使用。  </p><a id="more"></a><h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><p><a href="http://wiki.ros.org/sw_urdf_exporter" target="_blank" rel="noopener">http://wiki.ros.org/sw_urdf_exporter</a><br>官网上有很详细的说明，他不推荐用2018的SW，但是不幸的是我就是这个版本的，懒得换了，我也没发现有啥不对劲的（PS：现在我已经发现不对劲了，浪费了我好长时间，我都要手工写了整个URDF文件了）。<br>直接下载下来双击安装，记得改安装的路径安装到SW的目录下，WIN10应该是不区分大小写的。  </p><h1 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h1><p>装配体的装配关系并不影响最后的仿真,因为SW还没有智能到这种程度，真正在模型中起约束作用的还是link和joint的属性。<br>所以随便画了，镜像什么的随便用，一开始我还以为是不可以的。  </p><p>Solidworks中的零件被当做一个link，link可以指定许多属性：</p><ol><li><inertial>    定义惯性参数（Kinematic and dynamic description of the robot）</inertial></li><li><visual>      定义外观，大小，颜色和材质纹理贴图（Visual representation of the robot）</visual></li><li><collision>   定义碰撞检测属性（Collision model of the robot）</collision></li></ol><p>这些属性导出时和工具→评估→质量属性里的设置保持一致。</p><h1 id="构建基准轴和坐标系"><a href="#构建基准轴和坐标系" class="headerlink" title="构建基准轴和坐标系"></a>构建基准轴和坐标系</h1><img src="/2020/03/22/URDF的创建和使用/Snipaste_2020-03-22_17-03-50.png">  <p>这一步似乎是可以跳过的，因为后边SW可以选择自动生成。但是我们还是自己构建一下。<br>对joint和link的定义不理解的可以去看官方的Wiki还有像古月的博客，虽然我很烦那些卖套件和卖课的，但是这些基础的定义他们写的还是可以的（当然官网的是最全、最准确的，尽量看官网的）。<br>在下边的描述中我是默认读者对———— origin 描述的是joint相对父节点的相对位置、axis是描述joint的运动学参数等等是熟悉的。</p><p>下边我写的都是他们没有的。  </p><p>我理解的SW做的工作就是把基准轴转换成了joint，把坐标系转换成了对应link的坐标系，在生成link时零件和参考坐标系之间的相对位置不变的转换成了link和他的坐标系（这一点2018的SW经过我无数次的验证，已经确定是有BUG的，不要再用18了，他导出的STL坐标原点不在我规定的坐标原点，当然也可能是我的软件问题，毕竟没有交保护费）<br>总结起来就是，SW总共做了两件事：</p><ol><li>得到joint的位置和朝向（Axis）</li><li>将零件转化为link并定义link的坐标（frame）  </li></ol><h2 id="基准轴"><a href="#基准轴" class="headerlink" title="基准轴"></a>基准轴</h2><p>基准轴会转换成joint，我们需要自己指定轴的类型。<br>现有的选项有：</p><ol><li>revolute - 旋转关节，其极限位置由 upper and lower limits 决定，类似舵机的情况</li><li>continuous - 旋转关节，无位置限制，一般的电机可以用这个类型</li><li>prismatic - 滑动关节，其极限位置由 upper and lower limits 决定，用于滑轨等等</li><li>fixed - 虚拟关节，关节不可运动，用于直接固定，比如激光雷达双目等等直接固定在车体上的</li><li>floating - 六自由度关节</li><li>planar - 平面关节</li></ol><p>比如我们创建一个轮子的转轴：</p><ol><li>点击基准轴<img src="/2020/03/22/URDF的创建和使用/Snipaste_2020-03-28_21-09-02.png" title="点击基准轴axis">  </li><li>设置转轴方向  </li></ol><img src="/2020/03/22/URDF的创建和使用/Snipaste_2020-03-28_21-10-03.png" title="轮子以垂直轮子侧面的方向为轴做转动，转动中心由frame原点确定">  <img src="/2020/03/22/URDF的创建和使用/Snipaste_2020-03-28_21-11-01.png" title="建立完成之后可以拉长方便显示">  <p>这样我们的坐标轴就建好了，下边建立参考坐标系。</p><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>定义的坐标系在导出URDF之后是和link绑定的，frame的姿态就是link的姿态，frame绕轴做轴对应属性的运动，frame原点就是link的运动中心。<br>在ROS与SW中坐标系统一使用一下颜色定义：<br>红-》x 蓝色-》z 绿色-》y  </p><ol><li>点击坐标系<img src="/2020/03/22/URDF的创建和使用/Snipaste_2020-03-28_21-14-07.png" title="点击坐标系新建坐标系">  </li><li>确定frame的原点与朝向<img src="/2020/03/22/URDF的创建和使用/Snipaste_2020-03-28_21-18-08.png" title="确定原点与三个轴的朝向">  link是按frame的原点绕axis做运动的，所以我们应该把frame的原点设置在轮子的圆心处，可以看到我在旁边还设置了几个坐标系，如果最后选择那几个坐标系的话轮子就会绕那几个坐标系的原点转动，可以自己尝试一下。<br>同时我们的坐标系最好是按照ROS的规范进行设置，一般情况下我们的Z轴是朝上的，Y轴是向左的，X轴是向前的，满足右手坐标系，当然如果不这么干也可以，效果是一样的。<br>如果是滑轨之类的则一般Z轴为滑动方向，转动关节一般以Z轴为轴，当然这些都是一般情况，坐标系可以随便设置，不影响结果，只影响计算过程。  </li></ol><p>对每一个joint都重复以上操作，定义所有的joint。  </p><h1 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h1><p>点击 工具》file》Export as URDF 导出</p><img src="/2020/03/22/URDF的创建和使用/Snipaste_2020-03-28_21-37-13.png" title="导出">  <p>ros的TF是以树状的形式存在的，我们需要设置一个根link的frame，一般默认名字为base_link，比如我们的车子，我们将base_link建在中心的底板上，将frame1建立在第一个轮子（link1）上、将frame2建立在第二个轮子（link2）上……以此类推，我们可以得到我们的TF树为：  </p><pre class="mermaid">graph TBA[底盘/base_link]-->B[link1/frame1]A[底盘/base_link]-->C[link2/frame2]A[底盘/base_link]-->D[link3/frame3]A[底盘/base_link]-->E[link4/frame4]</pre><img src="/2020/03/22/URDF的创建和使用/Snipaste_2020-03-28_21-53-01.png" title="urdf_to_graphiz插件显示坐标变换">  <p>如果我们是一个机械臂就会出现一个链式的运动链。<br>我们车子坐标轴（Axis）和坐标系（frame）的总览：</p><img src="/2020/03/22/URDF的创建和使用/Snipaste_2020-03-28_21-43-34.png" title="总览">  <p>设置base_link:</p><img src="/2020/03/22/URDF的创建和使用/Snipaste_2020-03-28_22-03-36.png" title="设置根link"><p>设置子link和对应的轴属性：</p><img src="/2020/03/22/URDF的创建和使用/Snipaste_2020-03-28_22-02-58.png">  <p>都设置好之后可以点Preview and export进行导出，进入下边的配置界面，对joint进行设置，如果前边设置的都没问题这里基本不用动。  </p><img src="/2020/03/22/URDF的创建和使用/Snipaste_2020-03-28_20-57-01.png" title="设置joint">  <p>点下一步，可以进入link属性的设置，这里可以设置贴图（Texture）、质量、惯性张量、初始位置、材料颜色等特性，这里可以看上边画图那一步的说明。 点击Finish，在文件名中添加你的package的想要的名字（这个名字不能有中文，不然编译不过），就会生成一个完整的ros package。  </p><img src="/2020/03/22/URDF的创建和使用/Snipaste_2020-03-28_22-20-01.png" title="link的属性">  <p>我们可以看到下面这个目录：  </p><img src="/2020/03/22/URDF的创建和使用/Snipaste_2020-03-28_22-59-56.png" title="修改use_gui">  <p>导出之后导入到工作空间中，这个时候修改一下launch文件，打开use_gui选项，这样就可以使用ui直接拖动控制轮子</p><img src="/2020/03/22/URDF的创建和使用/Snipaste_2020-03-28_22-30-50.png" title="修改use_gui">  <h1 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h1><p>如果没有导出整个目录，则要将urdf文件导入到工作空间中，然后将STL文件导入到包中的meshes文件夹中（没有可以新建一个），可以使用下边的模板：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"model"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"gui"</span> <span class="attr">default</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"robot_description"</span> <span class="attr">textfile</span>=<span class="string">"$(find package_name)/urdf/SLDASM.urdf"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"use_gui"</span> <span class="attr">value</span>=<span class="string">"$(arg gui)"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"joint_state_publisher"</span> <span class="attr">pkg</span>=<span class="string">"joint_state_publisher"</span> <span class="attr">type</span>=<span class="string">"joint_state_publisher"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"robot_state_publisher"</span> <span class="attr">pkg</span>=<span class="string">"robot_state_publisher"</span> <span class="attr">type</span>=<span class="string">"state_publisher"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"rviz"</span> <span class="attr">pkg</span>=<span class="string">"rviz"</span> <span class="attr">type</span>=<span class="string">"rviz"</span> <span class="attr">args</span>=<span class="string">"-d $(find package_name)/rviz/urdf.rviz"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改其中的URDF文件路径就可以显示了，同时还需要修改launch文件中的STL搜索的路径，很容易看明白的，这里就不贴代码了。<br>我在2020的SW中安装了1.5.1版本的插件，生成的launch文件中urdf的路径是没问题的，但是其他版本的SW应该是不对的，我之前使用18的SW会生成：  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"robot_description"</span> <span class="attr">textfile</span>=<span class="string">"$(find package_name)/robots/SLDASM.urdf"</span> /&gt;</span>   <span class="comment">&lt;!-- 这里的robots应改为urdf  --&gt;</span></span><br></pre></td></tr></table></figure><p>机械臂和小车的形式是不一样的，机械臂有一个固定的底座，这个底座就是base_link,但是小车的话整个都是运动的，这一点要考虑进去。<br>下边贴一下我做的示例（应该是轮子1（link1）的frame不在原点处的示例）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- This URDF was automatically created by SolidWorks to URDF Exporter! Originally created by Stephen Brawner (brawner@gmail.com) </span></span><br><span class="line"><span class="comment">     Commit Version: 1.5.1-0-g916b5db  Build Version: 1.5.7152.31018</span></span><br><span class="line"><span class="comment">     For more information, please see http://wiki.ros.org/sw_urdf_exporter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">"SLDASM_6"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"base_link"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xyz</span>=<span class="string">"3.16257321540939E-19 2.78943508064166E-18 0.0025"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mass</span></span></span><br><span class="line"><span class="tag">        <span class="attr">value</span>=<span class="string">"0.36355871410233"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">inertia</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ixx</span>=<span class="string">"0.0019785762122608"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ixy</span>=<span class="string">"3.14121837617012E-19"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ixz</span>=<span class="string">"-1.06598079349227E-38"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">iyy</span>=<span class="string">"0.00227552353547264"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">iyz</span>=<span class="string">"-1.03397576569128E-22"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">izz</span>=<span class="string">"0.00425258491975801"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xyz</span>=<span class="string">"0 0 0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span></span></span><br><span class="line"><span class="tag">          <span class="attr">filename</span>=<span class="string">"package://SLDASM_6/meshes/base_link.STL"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">material</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">color</span></span></span><br><span class="line"><span class="tag">          <span class="attr">rgba</span>=<span class="string">"1 1 1 1"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xyz</span>=<span class="string">"0 0 0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span></span></span><br><span class="line"><span class="tag">          <span class="attr">filename</span>=<span class="string">"package://SLDASM_6/meshes/base_link.STL"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">joint</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"44"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">"continuous"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xyz</span>=<span class="string">"0.10304 -0.11866 -0.028"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">rpy</span>=<span class="string">"0 0 -1.0472"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span></span></span><br><span class="line"><span class="tag">      <span class="attr">link</span>=<span class="string">"base_link"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span></span></span><br><span class="line"><span class="tag">      <span class="attr">link</span>=<span class="string">"4"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">axis</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xyz</span>=<span class="string">"1 0 0"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xyz</span>=<span class="string">"-3.4694E-18 -0.028507 0.032624"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mass</span></span></span><br><span class="line"><span class="tag">        <span class="attr">value</span>=<span class="string">"0.14787"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">inertia</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ixx</span>=<span class="string">"7.1802E-05"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ixy</span>=<span class="string">"1.3715E-20"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ixz</span>=<span class="string">"-1.2607E-20"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">iyy</span>=<span class="string">"8.4923E-05"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">iyz</span>=<span class="string">"2.2725E-05"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">izz</span>=<span class="string">"0.00011116"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xyz</span>=<span class="string">"0 0 0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span></span></span><br><span class="line"><span class="tag">          <span class="attr">filename</span>=<span class="string">"package://SLDASM_6/meshes/1.STL"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">material</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">color</span></span></span><br><span class="line"><span class="tag">          <span class="attr">rgba</span>=<span class="string">"1 1 1 1"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xyz</span>=<span class="string">"0 0 0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span></span></span><br><span class="line"><span class="tag">          <span class="attr">filename</span>=<span class="string">"package://SLDASM_6/meshes/1.STL"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">joint</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"11"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">"continuous"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xyz</span>=<span class="string">"-0.13855 -0.09816 -0.028"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">rpy</span>=<span class="string">"1.5708 -1.5708 0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span></span></span><br><span class="line"><span class="tag">      <span class="attr">link</span>=<span class="string">"base_link"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span></span></span><br><span class="line"><span class="tag">      <span class="attr">link</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">axis</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xyz</span>=<span class="string">"0 0.5 0.86603"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xyz</span>=<span class="string">"0.014 1.3878E-17 0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mass</span></span></span><br><span class="line"><span class="tag">        <span class="attr">value</span>=<span class="string">"0.14787"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">inertia</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ixx</span>=<span class="string">"0.00012428"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ixy</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ixz</span>=<span class="string">"2.8141E-21"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">iyy</span>=<span class="string">"7.1802E-05"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">iyz</span>=<span class="string">"7.3107E-21"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">izz</span>=<span class="string">"7.1802E-05"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xyz</span>=<span class="string">"0 0 0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span></span></span><br><span class="line"><span class="tag">          <span class="attr">filename</span>=<span class="string">"package://SLDASM_6/meshes/2.STL"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">material</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">color</span></span></span><br><span class="line"><span class="tag">          <span class="attr">rgba</span>=<span class="string">"1 1 1 1"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xyz</span>=<span class="string">"0 0 0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span></span></span><br><span class="line"><span class="tag">          <span class="attr">filename</span>=<span class="string">"package://SLDASM_6/meshes/2.STL"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">joint</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"22"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">"continuous"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xyz</span>=<span class="string">"-0.10304 0.11866 -0.028"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">rpy</span>=<span class="string">"0 0 2.0944"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span></span></span><br><span class="line"><span class="tag">      <span class="attr">link</span>=<span class="string">"base_link"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span></span></span><br><span class="line"><span class="tag">      <span class="attr">link</span>=<span class="string">"2"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">axis</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xyz</span>=<span class="string">"1 0 0"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xyz</span>=<span class="string">"0.014 -2.0817E-17 0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mass</span></span></span><br><span class="line"><span class="tag">        <span class="attr">value</span>=<span class="string">"0.14787"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">inertia</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ixx</span>=<span class="string">"0.00012428"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ixy</span>=<span class="string">"-3.3881E-21"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ixz</span>=<span class="string">"1.679E-21"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">iyy</span>=<span class="string">"7.1802E-05"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">iyz</span>=<span class="string">"-1.739E-20"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">izz</span>=<span class="string">"7.1802E-05"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xyz</span>=<span class="string">"0 0 0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span></span></span><br><span class="line"><span class="tag">          <span class="attr">filename</span>=<span class="string">"package://SLDASM_6/meshes/3.STL"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">material</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">color</span></span></span><br><span class="line"><span class="tag">          <span class="attr">rgba</span>=<span class="string">"1 1 1 1"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xyz</span>=<span class="string">"0 0 0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span></span></span><br><span class="line"><span class="tag">          <span class="attr">filename</span>=<span class="string">"package://SLDASM_6/meshes/3.STL"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">joint</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"33"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">"continuous"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xyz</span>=<span class="string">"0.10304 0.11866 -0.028"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">rpy</span>=<span class="string">"0 0 1.0472"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span></span></span><br><span class="line"><span class="tag">      <span class="attr">link</span>=<span class="string">"base_link"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span></span></span><br><span class="line"><span class="tag">      <span class="attr">link</span>=<span class="string">"3"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">axis</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xyz</span>=<span class="string">"1 0 0"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"4"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xyz</span>=<span class="string">"3.1626E-19 2.7894E-18 0.0025"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mass</span></span></span><br><span class="line"><span class="tag">        <span class="attr">value</span>=<span class="string">"0.36356"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">inertia</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ixx</span>=<span class="string">"0.0019786"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ixy</span>=<span class="string">"3.1412E-19"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ixz</span>=<span class="string">"-1.066E-38"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">iyy</span>=<span class="string">"0.0022755"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">iyz</span>=<span class="string">"-1.034E-22"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">izz</span>=<span class="string">"0.0042526"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xyz</span>=<span class="string">"0 0 0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span></span></span><br><span class="line"><span class="tag">          <span class="attr">filename</span>=<span class="string">"package://SLDASM_6/meshes/4.STL"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">material</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">color</span></span></span><br><span class="line"><span class="tag">          <span class="attr">rgba</span>=<span class="string">"1 1 1 1"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xyz</span>=<span class="string">"0 0 0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span></span></span><br><span class="line"><span class="tag">          <span class="attr">filename</span>=<span class="string">"package://SLDASM_6/meshes/4.STL"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">joint</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"44"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">"continuous"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xyz</span>=<span class="string">"0.10304 -0.11866 -0.028"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">rpy</span>=<span class="string">"0 0 -1.0472"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span></span></span><br><span class="line"><span class="tag">      <span class="attr">link</span>=<span class="string">"base_link"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span></span></span><br><span class="line"><span class="tag">      <span class="attr">link</span>=<span class="string">"4"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">axis</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xyz</span>=<span class="string">"1 0 0"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS系列教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC-G++的使用</title>
      <link href="/2020/03/21/GCC-G-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/03/21/GCC-G-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>应广大群众的需求，整理一下编译工具的使用。</p><a id="more"></a><p>Gcc&amp;G++是GNU中的工具链，分别用来编译c&amp;c++文件。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc [options] [filenames] -o [targetfile]</span><br><span class="line">$ g++ [options] [filenames] -o [targetfile]</span><br></pre></td></tr></table></figure><p>options可以指定filenames文件编译的目标文件类型。<br>使用<code>-o</code>可以指定编译结果的名字，当然不指定也可以，会有默认的名字。<br>整个的编译流程为：</p><pre class="mermaid">graph LRA[.c]-->|预处理 -E|B[.i]B -->|编译 -S| C[.s]C -->|汇编 -c| D[.o]D -->|链接 | E[可执行,默认为a.out]</pre><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>除了上边提到的<code>-E -S -c -o</code>之外还有一些别的参数可以使用。  </p><h2 id="O"><a href="#O" class="headerlink" title="-O"></a>-O</h2><p>使用-O可以改变编译器对代码的优化等级，有时候不希望编译器在优化时改变我们的代码逻辑，这个时候可以用一个较低的优化等级<code>-O0</code>,-O指令可以加在g++&amp;gcc指令后的任何地方，使用方式为-On（n 常为0–3）。<br>优化等级越高，优化器对代码的改变也就越多，一般这个时候编译出来的可执行程序也就越快。<br>每一个等级的优化内容稍有不同：</p><p>-O  主要进行跳转和延迟退栈两种优化；  </p><p>-O2 除了完成-O1的优化之外，还进行一些额外的调整工作，如指令调整等。  </p><p>-O3 则包括循环展开和其他一些与处理特性相关的优化工作。  </p><p>选项将使编译的速度比使用 -O 时慢， 但通常产生的代码执行速度会更快。  </p><h2 id="l-amp-L"><a href="#l-amp-L" class="headerlink" title="-l &amp; -L"></a>-l &amp; -L</h2><p>参考我之前的一篇文章：<a href="https://www.qm-k.xyz/2019/08/18/pkg-config%E7%9A%84%E4%BD%BF%E7%94%A8/">pkg-config的使用</a><br><code>-l</code>参数是用来指定需要的链接库的，比如我们需要用到一个<code>librknn_api.so</code>的动态链接库，这个时候我们可以把这个文件放进<code>/usr/lib</code>中使得g++之类的工具能找到他，然后在参数中添加<code>-lrknn_api</code>,如果和这个库配套的头文件也是没问题的我们就可以直接编译出结果。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ XX.cpp -lrknn_api</span><br></pre></td></tr></table></figure><p>这个时候相信你也可以看出来一个动态链接库的命名方式了，把他对应的<code>.so</code>文件去掉<code>lib</code>和<code>.so</code>，剩下的就是编译工具能识别到的库名。<br>一般编译工具会在<code>/usr/lib</code>和<code>/usr/local/lib</code>文件夹中去找你需要的动态链接库，但是如果你的库不在这些路径下，这时候就需要使用<code>-L</code>来添加搜索路径，比如上边的<code>librknn_api.so</code>在<code>/usr/rknn/</code>目录下，就可以添加一个<code>-L/usr/rknn/</code>来使得编译工具能找到这个库。<br>比如这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ XX.cpp -lrknn_api -L/usr/rknn/</span><br></pre></td></tr></table></figure><p>经常编译一个开源源码遇到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: cannot find -lxxx”</span><br></pre></td></tr></table></figure><p>一般就是需要安装一下对应的库即可解决问题。  </p><p>手工来写链接参数总是很麻烦的，还好很多库开发包提供了生成链接参数的程序，名字一般叫xxxx-config，一般放在/usr/bin目录下，比如 gtk1.2的链接参数生成程序是gtk-config，用法类似pkg-config，可以去看我之前专门讲这个的文章，现在基本都是支持pkg-config的，所以这个可以不管，了解一下。</p><h2 id="i-amp-I"><a href="#i-amp-I" class="headerlink" title="-i &amp; -I"></a>-i &amp; -I</h2><p>他们的功能和<code>-l &amp; -L</code>功能类似，一个是添加头文件，一个是添加头文件路径，但是一般我们都在<code>.h</code>中使用<code>#include xxx.h</code>包含过了，所以主要就是用<code>-I</code>来声明头文件的目录，这个目录是可以用相对路径也可以用绝对路径的。<br>用法和上边的-L一致，就不细说了。  </p><h2 id="Wall、-w-和-v参数"><a href="#Wall、-w-和-v参数" class="headerlink" title="-Wall、-w 和 -v参数"></a>-Wall、-w 和 -v参数</h2><p>输出控制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Wall 打印出gcc提供的警告信息</span><br><span class="line">-w    关闭所有警告信息</span><br><span class="line">-v    列出所有编译步骤</span><br></pre></td></tr></table></figure><h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><p>参考我之前的一篇文章：<a href="https://www.qm-k.xyz/2019/08/18/pkg-config%E7%9A%84%E4%BD%BF%E7%94%A8/">pkg-config的使用</a><br>里边提到了一些像PKG_CONFIG_PATH这样用于pkg-config查找pc文件的环境变量说明可以看一下，同时还有后边要写的Makefile中的<code>CC</code>指定c编译器，<code>CXX</code>指定cxx编译器，CFLAGS等等。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>launch文件的使用</title>
      <link href="/2020/03/18/launch%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/03/18/launch%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在运行一个ROS工程的时候经常要同时打开很多的node，这个时候需要开很多的终端而且在调试参数时非常的麻烦，为了解决这个问题ROS提供了一个roslaunch的机制，方便同时运行多个nodes。  </p><a id="more"></a><p>launch文件是由XML格式写成的，遵循XML的书写规范。  </p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>启动一个launch文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch package_name launch_file_name</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch completely_path</span><br></pre></td></tr></table></figure><p>launch文件是不需要必须包含在package中的，可以直接用绝对路径启动，或者在所在路径下直接<code>roslauch launch_file_name</code>  </p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>先举一个完整的例子</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"model"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"gui"</span> <span class="attr">default</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"robot_description"</span> <span class="attr">textfile</span>=<span class="string">"$(find autolabor_description)/urdf/autolabor_pro1.urdf"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"use_gui"</span> <span class="attr">value</span>=<span class="string">"$(arg gui)"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 场景模拟 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"map_server"</span> <span class="attr">type</span>=<span class="string">"map_server"</span> <span class="attr">name</span>=<span class="string">"map_server"</span> <span class="attr">args</span>=<span class="string">"$(find simulation_launch)/map/amcl_map.yaml"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"simulation_stage"</span> <span class="attr">pkg</span>=<span class="string">"autolabor_simulation_stage"</span> <span class="attr">type</span>=<span class="string">"simulation_stage_node"</span> <span class="attr">output</span>=<span class="string">"screen"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"input_topic"</span> <span class="attr">value</span>=<span class="string">"map"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"output_topic"</span> <span class="attr">value</span>=<span class="string">"stage_map"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"real_map_frame"</span> <span class="attr">value</span>=<span class="string">"real_map"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"map_server"</span> <span class="attr">type</span>=<span class="string">"map_server"</span> <span class="attr">name</span>=<span class="string">"map_server"</span> <span class="attr">args</span>=<span class="string">"$(find simulation_launch)/map/amcl_map.yaml"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"joint_state_publisher"</span> <span class="attr">pkg</span>=<span class="string">"joint_state_publisher"</span> <span class="attr">type</span>=<span class="string">"joint_state_publisher"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"robot_state_publisher"</span> <span class="attr">pkg</span>=<span class="string">"robot_state_publisher"</span> <span class="attr">type</span>=<span class="string">"state_publisher"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"rviz"</span> <span class="attr">pkg</span>=<span class="string">"rviz"</span> <span class="attr">type</span>=<span class="string">"rviz"</span> <span class="attr">args</span>=<span class="string">"-d $(find simulation_launch)/rviz/amcl_simulation.rviz"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"tf"</span> <span class="attr">type</span>=<span class="string">"static_transform_publisher"</span> <span class="attr">name</span>=<span class="string">"base_link_to_laser"</span> <span class="attr">args</span>=<span class="string">"0.0 0.0 0.20 0.0 0.0 0.0 /base_link /lidar 10"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中对ROS的roslaunch文件参数展示的不是特别完整，完整的roslaunch文件包括下边几种元素：</p><ul><li>launch：launch文件的根元素</li><li>node：用于启动节点</li><li>param：设置参数服务器上的参数（参数服务器在param的小节中说明，有空再写）</li><li>machine：声明用于工作的设备，可以是本地的也可以是远程的</li><li>includ：声明包含的其他的launch文件</li><li>env：指定启动节点的环境变量</li><li>test：启动一个测试节点</li><li>arg：声明参数</li><li>env：</li><li>remap：用于声明重映射，例如两个话题的数据类型相同，一个只有订阅者一个只有发布者，这个时候想将发布的内容放到订阅的话题里时可以使用（有空再详写）</li><li>rosparam：</li><li>param：定义参数服务器上的参数<br>或许我叙述的不完整，常用的就是这些。  </li></ul><h2 id="launch"><a href="#launch" class="headerlink" title="launch"></a>launch</h2><p>launch文件是由XML语法构成的，所以会有一个根。<br>launch文件的根元素采用<code>&lt;launch&gt;</code>标签。  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--more--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><p>用于描述要启动的节点。<br>下边举个具体的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"package-name"</span> <span class="attr">type</span>=<span class="string">"executable-name"</span> <span class="attr">name</span>=<span class="string">"node-name"</span> <span class="attr">args</span>=<span class="string">"arg1 arg2 args.yaml"</span> <span class="attr">machine</span>=<span class="string">"machine-name"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>pkg:节点所在的功能包的名字</li><li>type：节点的可执行程序的名字（在Cmakelist中定义的编译目标）</li><li>name：节点运行时的名字</li><li>args：传递到节点的参数</li><li>machine：启动节点的指定机器，这里可以是SSH链接的远程服务器,会在machine标签中单独定义</li></ul><p>举个特殊例子说明一下特殊应用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"package-name"</span> <span class="attr">type</span>=<span class="string">"executable-name"</span> <span class="attr">name</span>=<span class="string">"node-name"</span> <span class="attr">args</span>=<span class="string">"--test"</span> <span class="attr">respawn</span>=<span class="string">"true"</span> <span class="attr">respawn_delay</span>=<span class="string">"10"</span> <span class="attr">required</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>args=”–test”：带有这个参数启动时，会去尝试加载，如果加载失败会自动重新加载。</li><li>respawn=”true”：节点退出时自动重启</li><li>respawn_delay=”10”：在respawn=”true”的情况下，如果需要重启会等待respawn_delay秒之后再重启</li><li>required=”true”：如果节点死掉了，就杀掉所有roslaunch</li></ul><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><h2 id="多窗口启动"><a href="#多窗口启动" class="headerlink" title="多窗口启动"></a>多窗口启动</h2><p>在需要在启动的某些节点中使用键盘做输入的情况下，我们不能让所有的信息在一个terminal中做输出，这个时候可以加参数<code>launch-prefix=”command-prefix”</code>使得每一个节点在单独的terminal中输出</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS系列教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SVM简述</title>
      <link href="/2020/03/17/SVM%E7%AE%80%E8%BF%B0/"/>
      <url>/2020/03/17/SVM%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>支持向量机SVM是一个有监督的ML算法，是一个很常用的分类算法。<br>在这个算法中，通过构建一个和输入数据维度一致的$n$维空间，并将数据映射到这个超空间内，以期望找到一个在这个空间内能将我们的数据分割成对应的类别的最佳超平面。  </p><a id="more"></a><p>和感知机不同的地方在于，SVM的基本模型是定义在特征空间上的间隔最大的线性分类器，是一个求正则化的合页损失函数最小化的问题。</p><h1 id="最佳超平面"><a href="#最佳超平面" class="headerlink" title="最佳超平面"></a>最佳超平面</h1><p>简单来讲就是</p><img src="/2020/03/17/SVM简述/Snipaste_2020-03-17_20-56-33.png">  <p>待续，先补充一下前边的文章。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 算法 </category>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K-means聚类简述</title>
      <link href="/2020/03/17/K-means%E8%81%9A%E7%B1%BB%E7%AE%80%E8%BF%B0/"/>
      <url>/2020/03/17/K-means%E8%81%9A%E7%B1%BB%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>k-means聚类是一种典型的无监督学习，很多时候我们没有足够多的先验数据，无法对已有的数据进行充足的标注，这个时候无监督学习就能帮助我们在无法预知结果时接近问题。  </p><a id="more"></a><p>而聚类算法简单来讲就是把一些数据划分成几个具备相似特征的组，每个组中的数据之间具备比其他组中数据跟高的关联性，也就是把特征相近的数据分入同一个组中。  </p><h1 id="K"><a href="#K" class="headerlink" title="K"></a>K</h1><p>在K-means聚类中，我们会把所有的数据划分为K个簇（cluster）（怎么确定K是多少呢？随缘试吧），得到K个数据组的中心。<br>那么我们如何得到呢？其实很简单：  </p><ol><li>随机在数据域中生成K个初始均值。</li><li>计算每一个数据到这几个初始均值的距离。按照距离的远近将每一个数据划分到对应的簇中，此时可以得到K个簇。</li><li>计算每个簇的形心，得到新的均值。</li><li>重复2、3步骤，直到收敛。  </li></ol><p>K-means面对的第一个问题是如何保证收敛，前面的算法中强调结束条件就是收敛，可以证明的是K-means完全可以保证收敛性。下面我们定性的描述一下收敛性，我们定义其损失函数如下：<br>$$<br>J = \sum_{j=1}^k \sum_{i=1}^n || x_i^{(j)} - c_j ||^2<br>$$<br>式子中：  </p><ul><li>k：簇的个数</li><li>n：簇内点数</li><li>$x_i^{(j)}$:簇内第$i$个点</li><li>$c_j$:第$i$个簇的形心</li></ul><p>这样就能求出数据域中所有数据到现有的形心之间的平方误差，而K-means的目标就是使得总体的群体内方差最小。所以该目标函数就可以作为其训练的终止条件。  </p><p>但是由于畸变函数J是非凸函数，意味着我们不能保证取得的最小值是全局最小值，也就是说k-means的结果会受到初值选取的影响。但如果你怕陷入局部最优，那么可以选取不同的初始值跑多遍k-means，这个时候就有了k-means++。  </p><h2 id="k-means"><a href="#k-means" class="headerlink" title="k-means++"></a>k-means++</h2><p>k-means++原理也很简单，主要在于初始化中心和多次判断上。<br>k-means++会多次初始化中心，每次都从输入的数据集中选取一个作为数据集的中心，然后再重复k-means的流程直到单次收敛。收敛之后再选取数据集中距离每一个形心最远的数据作为新的初始中心，再重复k-means的流程。<br>还有关于大样本优化的k-means算法等等这里不再详说，可以参考<a href="https://www.cnblogs.com/pinard/p/6164214.html。" target="_blank" rel="noopener">https://www.cnblogs.com/pinard/p/6164214.html。</a>  </p><p>关于k-means有一个很有趣的描述：  </p><blockquote>有四个牧师去郊区布道，一开始牧师们随意选了几个布道点，并且把这几个布道点的情况公告给了郊区所有的居民，于是每个居民到离自己家最近的布道点去听课。<p>听课之后，大家觉得距离太远了，于是每个牧师统计了一下自己的课上所有的居民的地址，搬到了所有地址的中心地带，并且在海报上更新了自己的布道点的位置。<br>牧师每一次移动不可能离所有人都更近，有的人发现A牧师移动以后自己还不如去B牧师处听课更近，于是每个居民又去了离自己最近的布道点……<br>就这样，牧师每个礼拜更新自己的位置，居民根据自己的情况选择布道点，最终稳定了下来。</p></blockquote><p></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 算法 </category>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux的启动</title>
      <link href="/2020/02/29/Linux%E7%9A%84%E5%90%AF%E5%8A%A8/"/>
      <url>/2020/02/29/Linux%E7%9A%84%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>简单叙述一下Linux的启动流程。</p><a id="more"></a><p>总共是三个步骤：</p><pre class="mermaid">graph LRA[Bootloader]-->B[kernal]B --> C[rootfs]</pre><p>在PC和嵌入式中，Linux的启动是不太一样的，一般在PC中都是使用BIOS引导硬件启动之后交给系统，但是在嵌入式中，则是使用bootloader进行硬件的初始话之后引导系统内核，再之后挂载根文件系统。区别在于BIOS不具备直接向内核传参的功能，bootloader的功能则相对更加强大一些。  </p><h1 id="嵌入式系统的构成"><a href="#嵌入式系统的构成" class="headerlink" title="嵌入式系统的构成"></a>嵌入式系统的构成</h1><img src="/2020/02/29/Linux的启动/20130911140900046.png">  <p>上图是一个嵌入式Linux系统的典型结构，划分成了4个区：</p><ol><li>Bootloader区存放的是Bootloader，它负责嵌入式系统最初的硬件初始化、驱动和内核加载。</li><li>参数区不是必须的，通常存放了一些系统参数，并且通常这个区是没有文件系统，参数以原始数据的格式来存放。</li><li>内核镜像区存放的Linux内核压缩镜像，它被解压后运行于内存，作为嵌入式设备的Linux操作系统。</li><li>文件系统区存放经过压缩的文件系统，它会被Linux内核解压并挂载，并作为各种应用程序、文件的主要载体。</li></ol><p>下面来讲解一下整个Linux的启动流程。  </p><h1 id="UBoot"><a href="#UBoot" class="headerlink" title="UBoot"></a>UBoot</h1><p>一块板子上电肯定是要先初始化硬件的，之后再引导内核、挂载文件系统。而初始化硬件这一步一般都是由bootloader实现的。<br>而最常用的bootloader就是UBoot。UBoot本质上就是一个挂载系统之前的裸机程序。<br>U-Boot，全称 Universal Boot Loader，是遵循GPL条款的开源项目，U-Boot是 从FADSROM、8xxROM、PPCBOOT逐步发展演化而来的。U-Boot发展至今，已经可以 实现非常多的功能，在操作系统方面，它不仅支持嵌入式Linux系统的引导，还支持NetBSD, VxWorks, QNX, RTEMS, ARTOS, LynxOS, Android等嵌入式操作系统的引导。在CPU架构方面 ，U-Boot支持PowerPC、MIPS、x86、ARM、NIOS、XScale等诸多常用系列的处 理器。U-Boot的主要作用是用来启动操作系统内核，它分为两个阶段，即boot + loader，boot阶段启动系统，初始化硬件设备，建立内存空间映射图，将系统的软硬件带到一个合适的状态，loader阶段将操作系统内核文件加载至内存，之后跳转到内核所在地址运行。  </p><p>U-Boot本身非常强大，包含了像烧写模式–如果在上电的时候进行操作可以在烧写模式下烧写系统，直接引导模式–直接加载系统，还有一些校验系统镜像完整性之类的功能。  </p><p>其boot和loader阶段的功能具体来讲就是下边几个阶段：<br>boot：</p><ol><li>硬件设备初始化。</li><li>加载U-Boot第二阶段代码到RAM空间。</li><li>设置好栈。</li><li>跳转到第二阶段代码入口。  </li></ol><p>loader：</p><ol><li>初始化本阶段使用的硬件设备。</li><li>检测系统内存映射。</li><li>将内核从存储区域（Flash、SD Card、eMMC）读取到RAM中。</li><li>为内核设置启动参数。</li><li>调用内核。</li></ol><h1 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h1><h2 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h2><p>Kernel即是Linux内核，Linux内核采用宏内核架构，即Linux大部分功能都 会在内核中实现，如外设的内核驱动、进程管理、内存管理、设备管理、文件管理以及网络管 理等功能，它们是运行在内核空间中；除 此之外还有一种与宏内核相反的内核架构——微内核（没错，就是那个沸腾的鸿蒙大力鼓吹的内核架构），它仅仅是将内核的基本功 能放入内核中 ，如进程管理、进程调度等，而其他的设备管理、文件管理等功能都放在内核空间之外，这种微内核的架构有很优越的扩展性，它 将系统分为各个小的功能模块，把设计难度大大降低。<br>而宏内核的设计架构则没有非常好的扩展性，但Linux在发展的过程中，很早就引入了内核模块（Loadable Kernel Module，LKM）这一机制，弥补了这一不足之处，内核模块全称为动态可加载内核模块，就是在内核运行时可以动态加载一组目标代码来实现某些特定的 功能，在这过程中不需要重新编译内核就可以实现动态扩展。模块是具有独立功能 的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核 的一部分在内核空间运行，这与运行在用户空间的进程是不同的。模块通常由一组 函数和数据结构组成，用来实现一种文件系统、一个驱动程序或其他内核上层的功能。  </p><h3 id="内核驱动Kernal-driver"><a href="#内核驱动Kernal-driver" class="headerlink" title="内核驱动Kernal driver"></a>内核驱动Kernal driver</h3><p>我们经常提的Linux设备驱动就属于内核的一部分，由于UBoot不能很大，所以在UBoot工作的阶段只会初始化必要的资源，多数外设的驱动需要放在内核启动的阶段进行加载，Linux内核驱动的一个模块可以以两种方式被编译和加载：</p><ol><li>直接编译进Linux内核，随同Linux启动时加载。</li><li>编译成一个可加载和删除的模块。  </li></ol><p>这就是上边所说的LKM机制。<br>驱动程序向内核添加了一些函数，是内核的一部分。例如Open(), Release(), Read(), Write()。这些函数由内核在适当的时候来调用，可以用来完成硬件访问等操作。驱动程序占kernel源代码超过50%。  </p><p>内核中printk()函数的设计目的并不是为了和用户交流，它实际上是内核的一种日志机制，用来记录下日志信息或者给出警告提示。如果syslogd 和klogd 守护进程在运行的话，则不管是否向控制台输出，消息都会被追加进/var/log/messages 文件。klogd只处理内核消息，syslogd 处理其他系统消息，比如应用程序。  </p><h2 id="Linux系统的组成"><a href="#Linux系统的组成" class="headerlink" title="Linux系统的组成"></a>Linux系统的组成</h2><img src="/2020/02/29/Linux的启动/imagec004.jpeg">  <h3 id="文件管理子系统"><a href="#文件管理子系统" class="headerlink" title="文件管理子系统"></a>文件管理子系统</h3><p>在Linux系统中有一个重要的概念：一切皆文件，它把一切资源都看作是文件，包括硬件设备，通常称为设备文件。Linux的文件管理子系统主要实现了虚拟文件系统（Virtual File System，VFS），虚拟文件系统屏蔽了各种硬件上的差异以及具体实现的细节，为所有的硬件设备提供统一的接口，这样子也就实现了设备无关性，同时文件管理系统还为应用层提供统一的API接口。<br>总的来说，Linux 的文件系统体系结构是对一个对复杂系统进行了抽象化，通 过使用一组通用的 API 函数，Linux 可以在许多种存储设备上支持多种文件系统，如NTFS、EXT2、EXT3、EXT4 、FAT等等；而用户空间包含一些应用程序和 GNU C 库（glibc），它们使用的API接口是由系统调用层提供（如打开、读、写和关闭等），其框架如下图所示。  </p><img src="/2020/02/29/Linux的启动/imagec008.png"><h3 id="设备子系统"><a href="#设备子系统" class="headerlink" title="设备子系统"></a>设备子系统</h3><p>设备子系统又被称之为设备驱动，由于嵌入式设备多种多样，所以内核选择了一种抽象的方式去描述设备，同时提供了各种内核驱动框架。<br>系统调用层是Linux内核与应用程序之间的接口，而设备驱动则是Linux内核与硬件之间的接口，设备驱动程序为应用程序屏蔽了硬件的细节，这样在应用程序看来，硬件设备只是一个设备文件，应用程序可以象操作普通文件一样对硬件设备进行操作（打开、读、写和关闭）。设备驱动程序是内核的一部分，它主要完成以下的功能：</p><ol><li>对设备初始化和释放</li><li>把数据从内核传送到硬件和从硬件读取数据</li><li>读取应用程序传送给设备文件的数据和回送应用程序请求的数据</li><li>检测和处理设备出现的错误</li></ol><p>Linux在发展的时候就根据设备的共性将设备分层3大类，分别为：</p><ul><li>字符设备</li><li>块设备</li><li>网络设备</li></ul><p>先说说网络设备，它其实就是网络子系统中描述的网络设备层，它其实也是一个抽象，统一描述了不同的网卡设备，如WIFI、以太网等。因为网络设备存在协议栈（协议族），它涉及了网络层协议，所以Linux将网络设备单独分层一类设备，网络设备的传输速率通常是很高的。  </p><p>字符设备是以字节为单位传输的IO设备，可以提供连续的数据流，应用程 序可以顺序读取，通常不支持随机存取。这种字符传输的效率通常是比较低的，如鼠标、键盘、串口等都是字符设备，也是一种比较常见的设备。  </p><p>块设备是以块为单位进行传输的设备，应用程序可以随机访问块设备中的数据，程序可以指定读取数据的位置。我们的磁盘就是一种常见的块设备，应用程序可以寻址磁盘上的任何位置，并在这个位置读取数据。不过需要注意的是，块设备读取的数据只能以块为单位的倍数进行（通常是512Byte的整数倍），而不能与字符设备一样以字节为单位读取，因此通常来说块设备的传输速度是比较高的。  </p><img src="/2020/02/29/Linux的启动/imagec010.png">  <h1 id="根文件系统"><a href="#根文件系统" class="headerlink" title="根文件系统"></a>根文件系统</h1><p>此处讲解的文件系统是根文件系统（rootfs），它是linux在初始化时 加载的第一个文件系统，和文件管理子系统小节所说的文件系统不同，这两个是不同的概念。根文件系统包括根目录和真实文件系统，根文件系统之所以在前面加一个“根”，说明它是加载其它文件系统的“根”，如果没有这个“根”的 话，其它的文件系统也就没有办法进行加载的。因为它包含系统引导和使 其他文件系统得以挂载（mount）所必要的文件。根文件系统包函Linux启动时 所必须的目录和关键性的文件，例如Linux启动时必要的初始化文件，它在init目录下，此 外根文件系统中还包括了许多的应用程序bin目录等，任何包括这些Linux 系统启动所必须的文件都可以成为根文件系统。</p><p>在Linux内核启动的初始阶段，首先内核会初始化一个基于内存的文件系 统，如initramfs，initrd等，然后以只读的方式去加载根文件系统（load rootfs），读取并 且运行/sbin/init初始化文件，根据/etc/inittab配置文件完成系统的初始化工作（提示：/sbin/init是 一个二进制可执行文件，为系统的初始化程序，而/etc/inittab是它的配置文件），在初 始化的过程中，还会以读写的方式重新挂载根文件系统，在系统启动后，根文件系统就可用于存储数据了，存在根文件系统是Linux启动时的必要条件。</p><p>Linux中的文件系统多种多样，同时在Linux中一切皆是文件，普通文件、目录、字符 设备、块设备、套接字等都以文件方式被抽象化；且它们需要向上层提供统一的操作接口。虚拟文 件系统VFS就是Linux内核中的一个软件层，向上给用户空间程序提供文件系统操作接口；向下允许不同的文件系统共存，所以，所有实际文件系统都必须实现VFS的结构封装。因为无论是访问设备还是需要通过文件系统来访问它的挂载点。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式搬砖手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运动学模型分析</title>
      <link href="/2020/02/15/%E8%BF%90%E5%8A%A8%E5%AD%A6%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90/"/>
      <url>/2020/02/15/%E8%BF%90%E5%8A%A8%E5%AD%A6%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>里程计模型包括运动学模型和航迹推算（Dead Reckoning），这里重点分析一下常见的运动学模型。</p><a id="more"></a><h1 id="两轮差分运动模型"><a href="#两轮差分运动模型" class="headerlink" title="两轮差分运动模型"></a>两轮差分运动模型</h1><img src="/2020/02/15/运动学模型分析/2wd.png"><p>两轮是一个典型的欠驱动系统（自由度大于驱动——输入数的系统就是欠驱动系统）,两个轮子作为输入，三个自由度，所以他的三个自由度是耦合的，不能对他的xy速度进行分解。<br>而两轮的所有运动，不论是直线运动还是曲线运动，其实都是可以分解为圆弧运动的，当圆弧运动的半径$R \to \infty$时，我们就可以认为他做的是一个直线运动了,反之$R \to 0$时则可以做原地自转。<br>由上边的推论我们可以知道：<br>$$<br>v = \frac{v_R + v_Y}{2} \\<br>\omega = \frac{v_R - v_L}{2d}<br>$$<br>下边是具体的推导：<br>由于两个轮子的角速度一定是相等的，所以我们可以得到<br>$$<br>\omega = \frac{v_L}{ r - d } = \frac{v_R}{ r + d }<br>$$<br>对其进行化简可得：<br>$$<br>r = \frac{(v_R + v_L)d}{v_R - v_L}<br>$$<br>再把计算的r值带回$\omega$的式子可得：<br>$$<br>\omega = \frac{v_R - v_L}{2d}<br>$$<br>同理，角速度再乘上r就可以算出线速度：<br>$$<br>v = \omega * r = \frac{v_L}{ r - d } = \frac{v_R}{ r + d } * \frac{(v_R + v_L)d}{v_R - v_L} = \frac{v_R + v_Y}{2}<br>$$</p><h1 id="三轮全向运动模型"><a href="#三轮全向运动模型" class="headerlink" title="三轮全向运动模型"></a>三轮全向运动模型</h1><p>三轮和四轮的全向都是具备全向移动能力的，但是他们都是全驱动系统，可以进行运动学分解。  </p><p>首先明确一点，在ROS和我们常用的分析场景下，我们都用的是右手坐标系，下边使用的坐标系并不合理，之后有空重新画图再推导。  </p><p>在网上可以看到各种模型分析，第一步都是建立坐标系,为了保证公式的通用性，定义了其中一个轮子的轴线在世界坐标系下的偏转角为$\alpha$，同时以这个轮子的的轴线方向作为Y轴，然而事实上这个轴线方向是会导致最后的公式发生改变的，所以并不会有标准的唯一解：</p><img src="/2020/02/15/运动学模型分析/2018081519113691.png" title="平行于两个轮子做X轴方向">  <p>首先建立世界坐标系X′O′Y′，然后再建立机器人自身的坐标系XOY。  </p><p>设车子的半径为$R$，移动平台自身的角速度为$\omega$，设顺时针为角速度正方向，各个轮子的速度分别为Va，Vb，Vc。设车子在XOY坐标系下的分速度为Vx，Vy。  </p><p>夹角$\theta_1 = π / 3 , \theta_2 = π / 6$ ,这个两个夹角是由右手螺旋定则确定的轮子线速度正方向与X、Y轴方向的夹角，拇指向外逆时针为正方向。  </p><p>这个坐标系并不合理，准备替换新的坐标系。</p><p>$\alpha$是两个坐标系的夹角。  </p><p>下面先计算在本身坐标系下轮子的速度：  </p><p>通过简单的矢量分解，将X、Y方向上的速度分解到沿轮子方向，我们可以得到：<br>$$<br>V_a = V_x + \omega R \\<br>V_b = -V_x \cos(\theta_1) - V_y \sin(\theta_1) + \omega R \\<br>V_c = -V_x \sin(\theta_2) + V_y \cos(\theta_2) + \omega R<br>$$<br>用矩阵来表示就是：<br>$$<br>\begin{bmatrix}<br>    V_a\\<br>    V_b\\<br>    V_c<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>    1 &amp; 0 &amp; R \\<br>    -\cos\theta_1 &amp; -\sin\theta_1 &amp; R \\<br>     -\sin\theta_2 &amp; \cos\theta_2 &amp; R<br>\end{bmatrix}<br>\begin{bmatrix}<br>    V_x\\<br>    V_y\\<br>    V_\omega<br>\end{bmatrix}<br>$$<br>这时候我们就得到了在机器人坐标系下的逆解结果，但是我们希望我们从我们操作者的视角去理解机器人的运动，这时候就应该由一个固定的坐标系来解释机器人的速度和姿态。  </p><p>也就是说，我们需要一个在世界坐标系下的逆解，这个很简单，我们只要知道了从$X\prime O Y\prime$到$XOY$坐标系下的旋转矩阵即可。  </p><p>我们已经假设过坐标系的偏转角为$\alpha$,所以可将小车的坐标系进行分解得到$XOY$到$X\prime O Y\prime$的旋转矩阵，再进行求逆得到$X\prime O Y\prime$到$XOY$坐标系的转旋矩阵，或者直接分解$X\prime O Y\prime$得到：<br>$$<br>\begin{bmatrix}<br>    V_x\\<br>    V_y\\<br>    V_\omega<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>    \cos\alpha &amp; \sin\alpha &amp; 0 \\<br>    -\sin\alpha &amp; \cos\alpha &amp; 0 \\<br>    0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>\begin{bmatrix}<br>    V_{x\prime}\\<br>    V_{y\prime}\\<br>    V_{\omega\prime}<br>\end{bmatrix}<br>$$<br>将其带入到机器人自身的坐标系中，即可得到在世界坐标系中的逆解结果。<br>$$<br>\begin{bmatrix}<br>    V_a\\<br>    V_b\\<br>    V_c<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>    1 &amp; 0 &amp; R \\<br>    -\cos\theta_1 &amp; -\sin\theta_1 &amp; R \\<br>     -\sin\theta_2 &amp; \cos\theta_2 &amp; R<br>\end{bmatrix}<br>\begin{bmatrix}<br>    \cos\alpha &amp; \sin\alpha &amp; 0 \\<br>    -\sin\alpha &amp; \cos\alpha &amp; 0 \\<br>    0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>\begin{bmatrix}<br>    V_{x\prime}\\<br>    V_{y\prime}\\<br>    V_{\omega\prime}<br>\end{bmatrix}<br>$$<br>化简得：<br>$$<br>\begin{bmatrix}<br>    V_a\\<br>    V_b\\<br>    V_c<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>    \cos\alpha &amp; \sin\alpha &amp; R \\<br>    -\cos\theta_1\cos\alpha +\sin\theta_1\sin\alpha &amp;  -\cos\theta_1\cos\alpha -\sin\theta_1\cos\alpha &amp; R \\<br>    -\sin\theta_2\cos\alpha -\cos\theta_2\sin\alpha &amp;  -\sin\theta_2\sin\alpha +\cos\theta_2\cos\alpha &amp; R<br>\end{bmatrix}<br>\begin{bmatrix}<br>    V_{x\prime}\\<br>    V_{y\prime}\\<br>    V_{\omega\prime}<br>\end{bmatrix}<br>$$<br>这个时候输入的未知量就只有偏转角$\alpha$和目标的线速度和角速度，而偏转角$\alpha$可以通过陀螺仪等方式测量出来，所以这时候就可以直接使用这个公式进行逆解，计算出轮子的目标转速。  </p><p>同时另一个问题就是，在计算PID时，由于电机有相应范围，所以对目标值也是有约束范围的，这个时候就要看运动学公式逆解出的结果是不是在需要的区间上，这个时候再考虑是否要添加系数对其结果进行约束。  </p><p>自身坐标系：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _sqrt_of_3 1.73205f</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Omni3</span>:</span><span class="keyword">public</span> Model&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Omni3() &#123;&#125;</span><br><span class="line">    Omni3(<span class="keyword">float</span> _wheel_radius, <span class="keyword">float</span> _body_radius) : Model(_wheel_radius, _body_radius) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">motion_solver</span><span class="params">(<span class="keyword">float</span>* robot_speed, <span class="keyword">float</span>* motor_speed)</span></span>&#123;</span><br><span class="line">        <span class="comment">//  以前轮为X轴正向，使用右手螺旋定则，与上边的坐标系稍有不同，逆时针旋转了90度</span></span><br><span class="line">        <span class="comment">//  轮子的转动方向也以右手螺旋定则为准</span></span><br><span class="line">        <span class="comment">//  robot_speed[0] x    robot_speed[1] y    robot_speed[2] z</span></span><br><span class="line">        <span class="comment">//  motor_speed[0] 前轮 motor_speed[1] 左轮 motor_speed[2] 右轮</span></span><br><span class="line">        motor_speed[<span class="number">0</span>] = (robot_speed[<span class="number">1</span>] + robot_speed[<span class="number">2</span>] * body_radius)/ wheel_radius;</span><br><span class="line">        motor_speed[<span class="number">1</span>] = (-robot_speed[<span class="number">0</span>]*_sqrt_of_3*<span class="number">0.5</span> - robot_speed[<span class="number">1</span>]*<span class="number">0.5</span> + robot_speed[<span class="number">2</span>] * body_radius) / wheel_radius;</span><br><span class="line">        motor_speed[<span class="number">2</span>] = (robot_speed[<span class="number">0</span>]*_sqrt_of_3*<span class="number">0.5</span> - robot_speed[<span class="number">1</span>]*<span class="number">0.5</span> + robot_speed[<span class="number">2</span>] * body_radius) / wheel_radius;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_odom</span><span class="params">(struct Odom* odom, <span class="keyword">float</span>* motor_dis, <span class="keyword">unsigned</span> <span class="keyword">long</span> interval)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (motor_dis[<span class="number">0</span>]!=<span class="number">0</span> || motor_dis[<span class="number">1</span>]!=<span class="number">0</span> || motor_dis[<span class="number">2</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//speed</span></span><br><span class="line">            <span class="keyword">double</span> dvx = (-motor_dis[<span class="number">1</span>]+motor_dis[<span class="number">2</span>])*_sqrt_of_3/<span class="number">3.0f</span>;</span><br><span class="line">            <span class="keyword">double</span> dvy = (motor_dis[<span class="number">0</span>]*<span class="number">2</span>-motor_dis[<span class="number">1</span>]-motor_dis[<span class="number">2</span>])/<span class="number">3.0f</span>;</span><br><span class="line">            <span class="keyword">double</span> dvth = (motor_dis[<span class="number">0</span>]+motor_dis[<span class="number">1</span>]+motor_dis[<span class="number">2</span>])/ (<span class="number">3</span> * body_radius);</span><br><span class="line">            <span class="comment">//double dvx = (-motor_dis[1]+motor_dis[2])*_sqrt_of_3/2.0f;</span></span><br><span class="line">            <span class="comment">//double dvy = (motor_dis[0]*2-motor_dis[1]-motor_dis[2])/2.0f;</span></span><br><span class="line">            <span class="comment">//double dvth = (motor_dis[0]+motor_dis[1]+motor_dis[2])/ (3 * body_radius);</span></span><br><span class="line">            odom-&gt;vel_x = dvx / dt; </span><br><span class="line">            odom-&gt;vel_y = dvy / dt; </span><br><span class="line">            odom-&gt;vel_z = dvth / dt; </span><br><span class="line"></span><br><span class="line">            <span class="comment">//odometry</span></span><br><span class="line">            <span class="keyword">double</span> dx = (-<span class="built_in">sin</span>(th)*motor_dis[<span class="number">0</span>]*<span class="number">2</span>+(-_sqrt_of_3*<span class="built_in">cos</span>(th)+<span class="built_in">sin</span>(th))*motor_dis[<span class="number">1</span>]+(_sqrt_of_3*<span class="built_in">cos</span>(th)+<span class="built_in">sin</span>(th))*motor_dis[<span class="number">2</span>])/<span class="number">3.0f</span>;</span><br><span class="line">            <span class="keyword">double</span> dy = (<span class="built_in">cos</span>(th)*motor_dis[<span class="number">0</span>]*<span class="number">2</span>+(-_sqrt_of_3*<span class="built_in">sin</span>(th)-<span class="built_in">cos</span>(th))*motor_dis[<span class="number">1</span>]+(_sqrt_of_3*<span class="built_in">sin</span>(th)-<span class="built_in">cos</span>(th))*motor_dis[<span class="number">2</span>])/<span class="number">3.0f</span>;</span><br><span class="line">            <span class="keyword">double</span> dth = (motor_dis[<span class="number">0</span>]+motor_dis[<span class="number">1</span>]+motor_dis[<span class="number">2</span>])/ (<span class="number">3</span> * body_radius);</span><br><span class="line">            </span><br><span class="line">            odom-&gt;x += dx;</span><br><span class="line">            odom-&gt;y += dy;</span><br><span class="line">            odom-&gt;z += dth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类定义与结构体定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Odom</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">    <span class="keyword">float</span> z;</span><br><span class="line">    <span class="keyword">float</span> vel_x;</span><br><span class="line">    <span class="keyword">float</span> vel_y;</span><br><span class="line">    <span class="keyword">float</span> vel_z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Model</span>&#123;</span></span><br><span class="line">    Model()&#123;&#125;</span><br><span class="line">    Model(<span class="keyword">float</span> _wheel_radius, <span class="keyword">float</span> _body_radius): wheel_radius(_wheel_radius), body_radius(_body_radius)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">float</span> _wheel_radius, <span class="keyword">float</span> _body_radius)</span></span>&#123;</span><br><span class="line">        wheel_radius = _wheel_radius;</span><br><span class="line">        body_radius = _body_radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Model()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//robot speed ------------&gt; motor speed</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">motion_solver</span><span class="params">(<span class="keyword">float</span>* robot_speed, <span class="keyword">float</span>* motor_speed)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//motor speed-------------&gt; robot speed</span></span><br><span class="line">    <span class="comment">//interval  ms</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">get_odom</span><span class="params">(struct Odom* odom, <span class="keyword">float</span>* motor_dis, <span class="keyword">unsigned</span> <span class="keyword">long</span> interval)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> wheel_radius;</span><br><span class="line">    <span class="keyword">float</span> body_radius;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="四轮全向运动模型"><a href="#四轮全向运动模型" class="headerlink" title="四轮全向运动模型"></a>四轮全向运动模型</h1><h1 id="阿克曼转向模型"><a href="#阿克曼转向模型" class="headerlink" title="阿克曼转向模型"></a>阿克曼转向模型</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/weixin_41995979/article/details/81704172" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41995979/article/details/81704172</a><br><a href="https://www.jianshu.com/p/70555123672c" target="_blank" rel="noopener">https://www.jianshu.com/p/70555123672c</a>  </p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 算法 </category>
          
          <category> SLAM、Navigation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 导航 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>参数的使用与tf工具的使用</title>
      <link href="/2020/02/15/%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8Etf%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/02/15/%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8Etf%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>server的实现</title>
      <link href="/2020/02/15/server%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/02/15/server%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>client的实现</title>
      <link href="/2020/02/15/client%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/02/15/client%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自定义话题消息类型</title>
      <link href="/2020/02/13/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%9D%E9%A2%98%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/02/13/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%9D%E9%A2%98%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>前边的publisher和subscriber使用了twist和post的消息类型，这些可以都是ros已经定义好的消息类型，只要包含相应的头文件即可使用，但是如果我们需要用我们自己的消息类型时该怎莫办呢？ros给我们提供了相应的自定义的手段。</p><a id="more"></a><h1 id="定义话题消息"><a href="#定义话题消息" class="headerlink" title="定义话题消息"></a>定义话题消息</h1><h2 id="定义msg文件"><a href="#定义msg文件" class="headerlink" title="定义msg文件"></a>定义msg文件</h2><p>我们可以定义8位整型：<code>uint8</code>在msg文件中–这个类型是由std_msgs提供的，在编译的时候ros会将这个文件展开，扩展成了一个包含这个消息类型的一系列类和对象的头文件，以供后边的程序调用，保存在<code>/devel/include/packagename/</code>目录下，ros会自动将数据对象扩展成对应的多种语言的数据类型。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string name</span><br><span class="line">uint8  age</span><br><span class="line">uint8  sex</span><br><span class="line"></span><br><span class="line">uint8 unknown = 0</span><br><span class="line">uint8 male    = 1</span><br><span class="line">uint8 female  = 2</span><br></pre></td></tr></table></figure><h2 id="package-xml中添加依赖"><a href="#package-xml中添加依赖" class="headerlink" title="package.xml中添加依赖"></a>package.xml中添加依赖</h2><p>使用了动态生成程序的依赖所以需要声明一下依赖的包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;message_generation&lt;/build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</span><br></pre></td></tr></table></figure><h2 id="CMakelist-txt添加编译选项"><a href="#CMakelist-txt添加编译选项" class="headerlink" title="CMakelist.txt添加编译选项"></a>CMakelist.txt添加编译选项</h2><p>打开CMakelist.txt之后就会看到里边有明确的提示，比如<code>##Generate messages in the &#39;msg&#39; folder</code>就提示要把自行创建的消息类型放在msg文件夹下（如果没有咋办？创建一个啊）然后按照下边的格式提示将文件名填进去即可。<br>如下：</p><ol><li><code>find_package(.....  message_generation)</code>使用message_generation这个包来生成新的msg  </li><li><code>add_message_files(FILES msgname.msg)</code>把自己创建的msg文件加入编译<br><code>generate_messages(DEPENDENCIES std_msgs)</code>调用消息进行生成</li><li>指定信息导出（也可以没有，并不影响结果） <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">catkin_package(</span><br><span class="line">#  INCLUDE_DIRS include</span><br><span class="line">#  LIBRARIES message_test</span><br><span class="line">   CATKIN_DEPENDS roscpp std_msgs</span><br><span class="line">#  DEPENDS system_lib</span><br><span class="line">   message_runtime</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>这个时候创建新的cpp文件并在其中引用了刚声明的消息类型时，需要在CMakelist.txt中，除了添加正常有的编译和连接之外还需要有一个<code>add_dependencies</code>。<br><code>add_dependencies</code>这个东西是两个target有关系时（target_link_libraries）并且依赖库也是通过编译源码产生的。这时候一句add_dependencies可以在直接编译上层target时，自动检查下层依赖库是否已经生成。没有的话先编译下层依赖库，然后再编译上层target，最后link depend target。<br>放在这里的功能就是先确保消息已经生成，如果还没有生成那就先去生成消息，之后再link catkin_LIBRARIES。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_executable(person_publisher src/person_publisher.cpp)</span><br><span class="line">target_link_libraries(person_publisher $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">add_dependencies(person_publisher $&#123;PROJECT_NAME&#125;_generate_messages_cpp)</span><br></pre></td></tr></table></figure><p>同样在工程根目录下进行<code>catkin_make</code>，可以在<code>devel/include/包名/</code>目录下发现对应的头文件。<br>之后如果需要引用可以直接包含<code>包名/头文件</code>即可像正常引用ros系统提供的标准消息类型一样去使用。  </p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>创建包名：message_test，在包目录下新建msg文件夹，在新建的msg目录下创建Message1.msg文件，并加入下边两个文件进行编译，之后启动两个节点，就可以看到有数据传送。<br>person_subscriber：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ros/ros.h&gt;</span><br><span class="line">#include &quot;message_test/Message1.h&quot;</span><br><span class="line"></span><br><span class="line">// 接收到订阅的消息后，会进入消息回调函数</span><br><span class="line">void personInfoCallback(const message_test::Message1::ConstPtr&amp; msg)</span><br><span class="line">&#123;</span><br><span class="line">    // 将接收到的消息打印出来</span><br><span class="line">    ROS_INFO(&quot;Subcribe Person Info: name:%s  age:%d  sex:%d&quot;, </span><br><span class="line"> msg-&gt;name.c_str(), msg-&gt;age, msg-&gt;sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    // 初始化ROS节点</span><br><span class="line">    ros::init(argc, argv, &quot;person_subscriber&quot;);</span><br><span class="line"></span><br><span class="line">    // 创建节点句柄</span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    // 创建一个Subscriber，订阅名为/person_info的topic，注册回调函数personInfoCallback</span><br><span class="line">    ros::Subscriber person_info_sub = n.subscribe(&quot;/person_info&quot;, 10, personInfoCallback);</span><br><span class="line"></span><br><span class="line">    // 循环等待回调函数</span><br><span class="line">    ros::spin();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>person_publisher:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ros/ros.h&gt;</span><br><span class="line">#include &quot;message_test/Message1.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    // ROS节点初始化</span><br><span class="line">    ros::init(argc, argv, &quot;person_publisher&quot;);</span><br><span class="line"></span><br><span class="line">    // 创建节点句柄</span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    // 创建一个Publisher，发布名为/person_info的topic，消息类型为learning_topic::Person，队列长度10</span><br><span class="line">    ros::Publisher person_info_pub = n.advertise&lt;message_test::Message1&gt;(&quot;/person_info&quot;, 10);</span><br><span class="line"></span><br><span class="line">    // 设置循环的频率</span><br><span class="line">    ros::Rate loop_rate(1);</span><br><span class="line"></span><br><span class="line">    int count = 0;</span><br><span class="line">    while (ros::ok())</span><br><span class="line">    &#123;</span><br><span class="line">        // 初始化learning_topic::Person类型的消息</span><br><span class="line">    message_test::Message1 person_msg;</span><br><span class="line">person_msg.name = &quot;Tom&quot;;</span><br><span class="line">person_msg.age  = 18;</span><br><span class="line">person_msg.sex  = message_test::Message1::male;</span><br><span class="line"></span><br><span class="line">        // 发布消息</span><br><span class="line">person_info_pub.publish(person_msg);</span><br><span class="line"></span><br><span class="line">       ROS_INFO(&quot;Publish Person Info: name:%s  age:%d  sex:%d&quot;, </span><br><span class="line">  person_msg.name.c_str(), person_msg.age, person_msg.sex);</span><br><span class="line"></span><br><span class="line">        // 按照循环频率延时</span><br><span class="line">        loop_rate.sleep();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS系列教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Subscriber的实现</title>
      <link href="/2020/02/13/Subscriber%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/02/13/Subscriber%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>接上一篇publish的实现，如果有操作不明白可以翻之前的文章。</p><a id="more"></a><img src="/2020/02/13/Subscriber的实现/Snipaste_2020-02-13_14-08-23.png" title="rqt_graph">  <h1 id="创建新包"><a href="#创建新包" class="headerlink" title="创建新包"></a>创建新包</h1><p>过程参考前一节，我们创建一个名为<code>pose_subscriber</code>的包，同时创建同名的可执行程序。<br>类似单片机的中断机制，一旦满足条件跳入指定的函数，这就是订阅者Subscriber。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ros/ros.h&gt;</span><br><span class="line">#include &quot;turtlesim/Pose.h&quot;</span><br><span class="line">void poseCallback(const turtlesim::Pose::ConstPtr&amp; msg)</span><br><span class="line">&#123;</span><br><span class="line">ROS_INFO(&quot;Turtle pose :x:%0.6f y:%0.6f&quot;,msg-&gt;x ,msg-&gt;y);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc ,char **argv)</span><br><span class="line">&#123;</span><br><span class="line">//初始话节点，节点名为Pose_subscriber</span><br><span class="line">ros::init(argc ,argv ,&quot;Pose_subscriber&quot;);</span><br><span class="line">//创建句柄</span><br><span class="line">ros::NodeHandle n;</span><br><span class="line">    //创建Subscriber，定义从/turtle1/pose话题进行接收，同时绑定回调函数为poseCallback，队列长度为10</span><br><span class="line">ros::Subscriber pose_sub = n.subscribe(&quot;/turtle1/pose&quot;,10,poseCallback);</span><br><span class="line">    //进入死循环进行等待，一旦subscribe指定的话题有数据，则触发绑定的回调</span><br><span class="line">ros::spin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个程序就是接受小乌龟的坐标信息，运行之前那个发布速度的节点之后，就可以看到实时返回变化的坐标值，同时计算图会有三个节点连接在一起。<br>这时候如果取消roscore的话会发生什么呢？什么都不会发生，因为ros master是用来辅助topic连接用的，一旦连接成功，他就没用了，关掉rosmaster节点也可以保证topic的正常使用。  </p><h2 id="CMakelist-txt"><a href="#CMakelist-txt" class="headerlink" title="CMakelist.txt"></a>CMakelist.txt</h2><p>经过两节个实例的使用，这个时候会注意到CMakelist.txt中有很多注释，CMakelist是一个很常用的管理C++工程的东西，单独的叙述后边有空再整理，但是这里这些注释是很有用的，他里边写了一些常规CMakelist中没有的东西。<br>总结ros生成的CMakelist.txt中包含的就是以下几个东西：</p><ul><li>必需的CMake版本：cmake_minimum_required()</li><li>软件包名：project()</li><li>查找编译依赖的其他CMake/Catkin包（声明依赖库）：find_package()</li><li>启动Python模块支持：catkin_python_package()</li><li>消息/服务/操作(Message/Service/Action)生成器：add_message_files(),add_service_files(),add_action_files()</li><li>调用消息/服务/操作生成：generate_messages()</li><li>指定包编译信息导出：catkin_package()</li><li>添加要编译的库和可执行文件：add_library()/add_executable()/target_link_libraries()</li><li>测试编译：catkin_add_gtest()</li><li>安装规则：install()<br>其中的生成器在下边的自定义消息中会使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS系列教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Publisher的实现</title>
      <link href="/2020/02/10/Publisher%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/02/10/Publisher%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>ros中我认为最重要的一点就是他构建了一套统一的通信机制,将硬件给隐藏掉,使得开发者可以专注于算法的研究.</p><a id="more"></a><h1 id="话题-topic"><a href="#话题-topic" class="headerlink" title="话题(topic)"></a>话题(topic)</h1><p>topic:<br>    话题是一个很常用的机制,如果学过操作系统,很容易就会把他和队列联系起来,先进先出,有固定长度.<br>    而用户不必关心他的具体实现,只需要按照固定的方式创建所需数据类型的topic,然后将需要发送的标准数据使用系统提供的方法进行发送,接收的节点用系统提供的方法进行接收,即可完成数据的交换.所以只要是系统提供的标准数据或是用户定义过的数据,就可以很轻松的使用一些集成好的算法包进行测试.</p><h1 id="发布-publish"><a href="#发布-publish" class="headerlink" title="发布(publish)"></a>发布(publish)</h1><p>这里以一个具体的例子来讲:</p><img src="/2020/02/10/Publisher的实现/Snipaste_2020-02-12_17-56-19.png" title="rqt_graph"><p>其中有两个node,一个topic,这里使用<a href="https://www.qm-k.xyz/2020/02/09/%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8C%85/">工作空间于功能包</a>中创建的包进行测试.<br>ros自带的小乌龟节点<code>rosrun turtlesim turtlesim_node</code>会根据<code>/turtle1/cmd_vel</code>话题的内容进行移动,所以我们自己写的publisher向该话题发布速度信息,能使得小乌龟动起来就说明我们的publish正常工作了.  </p><h1 id="涉及的操作"><a href="#涉及的操作" class="headerlink" title="涉及的操作"></a>涉及的操作</h1><table><thead><tr><th align="center">操作</th><th align="center">命令</th></tr></thead><tbody><tr><td align="center">编译</td><td align="center">$catkin_make <br> #只能在工程的根目录下进行，就是在上文的catkin_ws中</td></tr><tr><td align="center">启动小乌龟的节点</td><td align="center">$rosrun turtlesim turtlesim_node</td></tr><tr><td align="center">启动自己的节点</td><td align="center">$rosrun &lt;包名&gt; &lt;节点名&gt; <br> 包名是创建时的命令指定的也就是src目录下的文件夹名，可以进行多级嵌套以最深处的为准 <br> 节点名则为编译源文件时在CMakelist.txt中指定的可执行程序名，或为python等脚本语言的脚本名<br><em>注意：这个和系统运行时计算图中的节点不是一个东西，计算图中的节点是程序中使用ros::init()进行定义的</em></td></tr><tr><td align="center">图形化显示当前的节点关系</td><td align="center">$rosrun rqt_graph rqt_graph</td></tr><tr><td align="center">显示当前的话题列表</td><td align="center">$rostopic list</td></tr><tr><td align="center">生效环境变量</td><td align="center">$source devel/setup.bash</td></tr></tbody></table><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>要实现一个发布者需要四个环节：</p><ol><li>初始化ROS节点</li><li>向ROS Master注册节点信息包括发布的话题名和话题中的消息类型</li><li>创建消息数据</li><li>按照一定的频率进行发送<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ros/ros.h&gt;</span><br><span class="line">#include &lt;geometry_msgs/Twist.h&gt;</span><br><span class="line">int main(int argc ,char **argv )</span><br><span class="line">&#123;</span><br><span class="line">    //1. ROS节点初始化，定义计算图的节点名为vel_public</span><br><span class="line">    ros::init(argc,argv,&quot;vel_public&quot;);</span><br><span class="line">    //创建节点句柄</span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line">    //2. 新建发布者，设定消息类型为Twist，向/turtle1/vmd_vel话题发送消息，队列长度设为10</span><br><span class="line">    ros::Publisher turtle_vel_pub = n.advertise&lt;geometry_msgs::Twist&gt;(&quot;/turtle1/cmd_vel&quot;,10);</span><br><span class="line">    //设定循环周期，可以确定loop_rate.sleep()的时间</span><br><span class="line">    ros::Rate loop_rate(10);</span><br><span class="line"></span><br><span class="line">    while(ros::ok())</span><br><span class="line">    &#123;</span><br><span class="line">        //3. 初始化消息类型为twist</span><br><span class="line">        geometry_msgs::Twist vel_msg;</span><br><span class="line">        vel_msg.linear.x = 5 ; </span><br><span class="line">        vel_msg.angular.z = 2 ; </span><br><span class="line">        //根据publisher初始话的设置进行发布</span><br><span class="line">        turtle_vel_pub.publish(vel_msg);</span><br><span class="line">        ROS_INFO(&quot;Publisher connmend  %0.2f m/s , %0.2f rad/s&quot;,vel_msg.linear.x,vel_msg.angular.z);</span><br><span class="line"></span><br><span class="line">        loop_rate.sleep();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>c++在ROS中是使用CMake来管理的，修改包中的CMakelist.txt即可。过程很简单：</p><ol><li>设置需要生成的代码和可执行文件名（最后会生成在catkin_ws/devel/lib/包名/可执行程序，也就是节点名）：<code>add_executable(节点名 src/源文件)</code></li><li>链接需要的库：<code>target_link_libraries(节点名 ${catkin_LIBRARIES})</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_executable(vel_publisher src/vel_publisher.cpp) #编译</span><br><span class="line">target_link_libraries(vel_publisher $&#123;catkin_LIBRARIES&#125;) #链接</span><br></pre></td></tr></table></figure></li></ol><p>这些设置写在<code>install</code>的最后和<code>build</code>之前就可以,注释写的很清楚具体的书写规范和每一个命令的具体功能。</p><img src="/2020/02/10/Publisher的实现/Snipaste_2020-02-13_13-14-04.png"><p>之后直接回到工程根目录下catkin_make就可以，编译结束使用<code>source devel/setup.bash</code>刷新环境变量让系统能找到刚编译的包。  </p><img src="/2020/02/10/Publisher的实现/Snipaste_2020-02-13_13-25-18.png">  <p>100%即为编译成功。 </p><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$roscore #启动master节点</span><br><span class="line">$rosrun turtlesim turtlesim_node #打开小乌龟节点</span><br><span class="line">$rosrun 包名 节点名 #运行/devel/lib/包名/目录下的节点可执行程序</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS系列教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS工作空间与功能包</title>
      <link href="/2020/02/09/%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8C%85/"/>
      <url>/2020/02/09/%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h1><p>工作空间（workspace）是一个存放开发工程的文件夹，类似于vs新建的工程目录。</p><a id="more"></a><ol><li>src：代码空间 真正开发时关注的地方</li><li>build：编译空间 编译的中间文件，基为二进制文件，基本用不到</li><li>devel：开发空间 调试时的可执行文件存放的地方，<code>workspace/devel/lib/包名/可执行程序</code></li><li>install：安装空间 用来提交的可执行程序<h2 id="创建工作空间"><a href="#创建工作空间" class="headerlink" title="创建工作空间"></a>创建工作空间</h2><table><thead><tr><th align="center">操作</th><th align="center">命令</th></tr></thead><tbody><tr><td align="center">创建工作空间</td><td align="center"># mkdir -p ~/catkin_ws/src <br> # cd ~/catkin_ws/src <br> # catkin_init_workspace <br> # catkin_ws就是工程名，所以是可以随意起名的，但是src不可以，因为他是系统规定的目录结构($会引发bug所以这里暂时用#替代)</td></tr><tr><td align="center">编译工作空间</td><td align="center"># cd ~/catkin_ws/src <br> # catkin_make</td></tr><tr><td align="center">设置环境变量</td><td align="center">$ source devel/setup.bash</td></tr><tr><td align="center">检查环境变量</td><td align="center">$ echo #ROS_PACKAGE_PATH</td></tr></tbody></table></li></ol><p>创建并编译工作空间:  </p><img src="/2020/02/09/工作空间与功能包/Snipaste_2020-02-09_16-57-14.png" title="创建并编译工作空间">  <p>生效环境变量，同时进行检查:  </p><img src="/2020/02/09/工作空间与功能包/Snipaste_2020-02-09_16-58-45.png" title="生效环境变量，同时进行检查">  <p>生成的目录结构：</p><img src="/2020/02/09/工作空间与功能包/Snipaste_2020-02-09_17-04-28.png" title="生成的目录结构"><p>这时候会发现缺少install文件夹,如果需要生成，这个时候需要使用：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ catkin_make install</span><br></pre></td></tr></table></figure><h1 id="创建功能包"><a href="#创建功能包" class="headerlink" title="创建功能包"></a>创建功能包</h1><table><thead><tr><th align="center">操作</th><th align="center">命令</th></tr></thead><tbody><tr><td align="center">创建功能包</td><td align="center"># cd ~/catkin_ws/src <br> # catkin_create_pkg &lt; package_name &gt; [ depend1 ] [ depend2] ···</td></tr><tr><td align="center">编译功能包</td><td align="center"># cd ~/catkin_ws <br> # catkin_make <br> # source ~/catkin_ws/devel/setup.bash</td></tr></tbody></table><p>编译需要在工作空间的根目录下进行，而生成功能包则在需要生成的目录中进行生成。<br>在命令中&lt;&gt;是必须有的参数，[]是可选的，在catkin_create_pkg中可以通过在后边加上depend来指定依赖。  </p><img src="/2020/02/09/工作空间与功能包/Snipaste_2020-02-09_17-32-23.png" title="生成新的功能包">  <p>其中roscpp是cpp的依赖、rospy是python的依赖、std_msgs是标准的消息类型。<br>最后生成的目录：  </p><img src="/2020/02/09/工作空间与功能包/Snipaste_2020-02-09_17-38-46.png" title="生成新的功能包">  <p>进行编译：  </p><img src="/2020/02/09/工作空间与功能包/Snipaste_2020-02-09_17-43-09.png" title="编译">  <p>最后可以通过<code>$ source devel/setup.bash</code>来更新环境变量，告诉系统你创建了新的功能包。<br>其实系统是通过<code>ROS_PACKAGE_PATH</code>变量来找到系统中的功能包的，而<code>setup.bash</code>则是通过更新这个环境变量来使系统能找到新创建的包。<br>如果要查找系统中所有的包，可以像下边这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo #ROS_PACKAGE_PATH </span><br><span class="line">/root/catkin_ws/src:/opt/ros/melodic/share</span><br></pre></td></tr></table></figure><h2 id="package-xml"><a href="#package-xml" class="headerlink" title="package.xml"></a>package.xml</h2><p>在生成新的功能包时会生成除了src、includ、cmakelist.txt这些必备的文件和目录之外，还有一个必要的文件就是package.xml文件.<br>包含了功能包的作者信息和一些版权信息，包括作者的名字、邮箱，还有包的版本号，作者的一些注释等等.<br>同时最重要的就是会有依赖包的声明,在编译工程的时候,系统会通过package.xml文件检索依赖,如果检索不到就会报错.<br>之后如果再依赖新的包的话也可以在文件后边再新加依赖项.  </p><p>同时要记住一点,<strong>在同一个工作空间中是不允许有同名的功能包的,但是在不同的工作空间中是可以的</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS系列教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pip3的安装与更新</title>
      <link href="/2020/02/08/pip3%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E6%9B%B4%E6%96%B0/"/>
      <url>/2020/02/08/pip3%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><a id="more"></a><p>在Ubuntu系统上，一般会默认安装python2和python3，在阿里的云服务器上一般会附带pip2。如果需要更新python3，不要直接卸载，会导致系统崩溃，如果要安装pip3，可以直接执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-pip</span><br></pre></td></tr></table></figure><img src="/2020/02/08/pip3的安装与更新/Snipaste_2020-02-08_14-16-54.png" title="缺少pip3提示安装">  <p>如果太慢，可以将系统镜像源换为国内的,点进链接有详细的说明。</p><p><a href="https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.3e221b1126dWW1" target="_blank" rel="noopener">阿里镜像</a><br><a href="https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.3e221b1126dWW1" target="_blank" rel="noopener">https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.3e221b1126dWW1</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">清华镜像</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</a></p><h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install --upgrade pip</span><br></pre></td></tr></table></figure><p>更新成功会有：</p><img src="/2020/02/08/pip3的安装与更新/Snipaste_2020-02-08_14-28-34.png" title="缺少pip3提示安装">  <p>网络不好可以临时使用清华镜像进行更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U</span><br></pre></td></tr></table></figure><h1 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h1><p>更新之后<br>设为清华源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p>设为阿里源：<br>将<code>~/.pip/pip.conf</code>改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure><h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><p>如果报了下边的错（好早的错误了，现在应该已经修复了）</p>  <p>可以<code>sudo vi /usr/bin/pip3</code>，打开这个文件，之后进行修改：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pip <span class="keyword">import</span> main</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">sys.exit(main())</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pip <span class="keyword">import</span> __main__</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">sys.exit(__main__._main())</span><br></pre></td></tr></table></figure><p>保存即可正常使用。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 炼丹学基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性回归</title>
      <link href="/2020/01/31/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
      <url>/2020/01/31/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 算法 </category>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ORB特征提取与匹配</title>
      <link href="/2020/01/26/ORB%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E4%B8%8E%E5%8C%B9%E9%85%8D/"/>
      <url>/2020/01/26/ORB%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E4%B8%8E%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>提起特征点检测就绕不开ORB这个经典的检测算法，下边对ORB特征识别进行简单的叙述。</p><a id="more"></a><h1 id="ORB原理"><a href="#ORB原理" class="headerlink" title="ORB原理"></a>ORB原理</h1><p>ORB特征是将FAST特征点的检测方法与BRIEF特征描述子综合起来，先通过FAST特征点检测图像上存在的可用特征点，检测到之后在特征点附近的像素上通过BRIEF特征描述算子对特征点进行描述，在匹配阶段通过BRIEF特征描述算子计算得到的特征向量进行相似度判断进行匹配。</p><h1 id="特征点定义"><a href="#特征点定义" class="headerlink" title="特征点定义"></a>特征点定义</h1><p>图像特征点可以认为是图像中比较特殊的点，例如：阴影、高光、轮廓等等，在图像上<code>不平坦</code>的点，表现在图像矩阵上就是梯度高的像素，这样的一类像素点可以用来作为图像的特征进行识别和检测。  </p><h1 id="特征点的检测（FAST）"><a href="#特征点的检测（FAST）" class="headerlink" title="特征点的检测（FAST）"></a>特征点的检测（FAST）</h1><p>ORB采用FAST（features from accelerated segment test）算法来检测特征点。这个定义基于特征点周围的图像灰度值，检测候选特征点周围一圈的像素值，如果候选点周围领域内有足够多的像素点与该候选点的灰度值差别够大，则认为该候选点为一个特征点。<br>$$<br>N = \sum_{ x \forall{circle(p)} } \left| I(x) - I(p) \right| &gt; \varepsilon_d<br>$$<br>其中$I(x)$为圆周上任意一点的灰度，$I(p)$为圆心的灰度，$\varepsilon_d$为灰度值差得阈值，如果N大于给定阈值，一般为周围圆圈点的四分之三，则认为点p是一个特征点。  </p><img src="/2020/01/26/ORB特征提取与匹配/FAST_9.png" title="FAST">  <p>为了获得更快的结果，还采用了额外的加速办法。如果测试了候选点周围每隔90度角的4个点，应该至少有3个和候选点的灰度值差足够大，否则则不用再计算其他点，直接认为该候选点不是特征点。候选点周围的圆的选取半径是一个很重要的参数，这里为了简单高效，采用半径为3，共有16个周边像素需要比较。为了提高比较的效率，通常只使用N个周边像素来比较，也就是大家经常说的FAST-N。很多文献推荐FAST-9，作者的主页上有FAST-9、FAST-10、FAST-11、FAST-12，大家使用比较多的是FAST-9和FAST-12。  </p><h1 id="计算特征描述子（BRIEF）"><a href="#计算特征描述子（BRIEF）" class="headerlink" title="计算特征描述子（BRIEF）"></a>计算特征描述子（BRIEF）</h1><p>得到特征点后我们需要以某种方式描述这些特征点的属性。这些属性的输出我们称之为该特征点的描述子（Feature DescritorS）。ORB采用BRIEF算法来计算一个特征点的描述子。  </p><p>BRIEF算法的核心思想是在关键点P的周围以一定模式选取N个点对，把这N个点对的比较结果组合起来作为描述子。<br>在选取点对时有多种方法，设我们在特征点的邻域块大小为S×S内选择n个点对(p,q)：</p><ul><li>在图像块内平均采样；</li><li>p和q都符合(0,125S2)的高斯分布；</li><li>p符合(0,125S2)的高斯分布，而q符合(0,1100S2)的高斯分布；</li><li>在空间量化极坐标下的离散位置随机采样</li><li>把p固定为(0,0)，q在周围平均采样<img src="/2020/01/26/ORB特征提取与匹配/RRIEF_5.png" title="RRIEF5种情况">  </li></ul><p>假设我们选到的点对的流程为：</p><ol><li>以关键点P为圆心，以d为半径做圆O。</li><li>在圆O内某一模式选取的N个点对。这里为方便说明，N=4，实际应用中N可以取很高。  <img src="/2020/01/26/ORB特征提取与匹配/RRIEF.png" title="RRIEF得到的4对算子">  </li><li>定义四个点对为：<br>$$<br>P_1(A,B) ,P_2(A,B) ,P_3(A,B) ,P_4(A,B)<br>$$</li><li>定义T运算：<br>$$<br>T_i(P_i(A,B))=<br>\begin{cases}<br>1\qquad I_A &gt; I_B\\<br>0\qquad I_B \leq I_B<br>\end{cases}<br>$$</li><li>对图中的四个点对进行T运算，并组合成一个向量：<br>$$<br>T_1 (P_1(A,B))=1\\<br>T_2 (P_2(A,B))=0\\<br>T_3 (P_3(A,B))=1\\<br>T_4 (P_4(A,B))=1<br>$$<br>可得最终的描述子为$T=1101$<h2 id="理想的特征点描述子应该具备的属性"><a href="#理想的特征点描述子应该具备的属性" class="headerlink" title="理想的特征点描述子应该具备的属性"></a>理想的特征点描述子应该具备的属性</h2>人在观察一张图像的时候是不关心图像的摆放、明暗、大小的，人眼都可以准确的根据图像的特征对内容进行判断，相应的我们的描述子也应该有这样的特性，应该具有尺度一致性、旋转一致性等。<br>BRIEF的优点在于速度，缺点也相当明显：</li></ol><ul><li>不具备旋转不变性。</li><li>对噪声敏感</li><li>不具备尺度不变性。<br>在在OpenCV中的ORB使用了图像金字塔解决了尺度一致性，下边来解决一下旋转一致性和噪声的问题。  <h2 id="旋转一致性"><a href="#旋转一致性" class="headerlink" title="旋转一致性"></a>旋转一致性</h2>在当前关键点P周围以一定模式选取N个点对，组合这N个点对的T操作的结果就为最终的描述子。当我们选取点对的时候，是以当前关键点为原点，以水平方向为X轴，以垂直方向为Y轴建立坐标系。当图片发生旋转时，坐标系不变，同样的取点模式取出来的点却不一样，计算得到的描述子也不一样，这是不符合我们要求的。因此我们需要重新建立坐标系，使新的坐标系可以跟随图片的旋转而旋转。这样我们以相同的取点模式取出来的点将具有一致性。  </li></ul><p>简而言之，就是让<strong>提取关键点的坐标系能够跟随图像旋转同时旋转</strong>（如下图），这样就可以保证在图像旋转前后提取的数据一致。  </p><img src="/2020/01/26/ORB特征提取与匹配/旋转一致性.png" title="旋转一致性">  <p>而要实现旋转一致性，只要找到”质心”即可，因为质心是固定的，会随物体转动而转动。<br>我们设Q为重心，我们以$P \rightarrow Q$为x轴，以P为原点，这样旋转时坐标就可以跟着旋转，在不同的旋转角度下，我们以同一取点模式取出来的点就是一致的。  </p><p>由高中物理可知，质量密度不均匀的物体质心坐标公式为：<br>二维<br>$$<br>\begin{aligned}<br>    \overline{x} = \frac{1}{M} \iint_D x \mu (x,y) d \sigma = \frac{\iint_D x \mu (x,y) d \sigma }{\iint_D \mu (x,y) d \sigma}  \\<br>    \overline{y} = \frac{1}{M} \iint_D y \mu (x,y) d \sigma = \frac{\iint_D y \mu (x,y) d \sigma }{\iint_D \mu (x,y) d \sigma}<br>\end{aligned}<br>$$<br>三维也同理，但是类比到图像上只需要二维即可，将像素的像素值作为其质量：<br>$$<br>M = \sum_{X=-R}^{R} \sum_{Y=-R}^{R} I(x,y)\\<br>M_{\overline{x}} = \sum_{X=-R}^{R} \sum_{Y=-R}^{R} xI(x,y)\\<br>M_{\overline{y}} = \sum_{X=-R}^{R} \sum_{Y=-R}^{R} yI(x,y)\\<br>Q_X = \frac{M_{\overline{x}}}{M},Q_Y = \frac{M_{\overline{y}}}{M} \qquad \text{X坐标，Y坐标}<br>$$<br>可以得到“质心”的坐标和角度<br>$$<br>O = \left( \frac{M_{\overline{x}}}{M} , \frac{M_{\overline{y}}}{M} \right) \qquad \text{坐标}\\<br>\theta = atan2( \frac{M_{\overline{x}}}{M_{\overline{y}}} ) \qquad \text{与x轴正向夹角}<br>$$</p><h2 id="滤波"><a href="#滤波" class="headerlink" title="滤波"></a>滤波</h2><p>BRIEF中，采用了9x9的高斯算子进行滤波，可以一定程度上解决噪声敏感问题，但是单纯的一个滤波是不够的，在ORB中我们通过对生成的点对附近的图像进行积分代替对应点的灰度值。<br>$$<br>I(A) = \sum_{x=-r}^{r} \sum_{y=-r}^{r} I(x,y)<br>$$</p><h1 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h1><p>计算两个特征点描述子之间的相似度即可，例如特征点A、B：<br>A = 1001110110<br>B = 0110110010<br>共计10位，其中5位相同，所以此时的相似度为50%，此时我们如果设置一个阈值即可判断A、B是否为匹配的。</p><h2 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h2><p>两个等长字符串之间的汉明距离是两个字符串对应位置的不同字符的个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hammingDistance</span><span class="params">(s1, s2)</span>:</span></span><br><span class="line">    <span class="string">"""Return the Hamming distance between equal-length sequences"""</span></span><br><span class="line">    <span class="keyword">if</span> len(s1) != len(s2):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"Undefined for sequences of unequal length"</span>)</span><br><span class="line">    <span class="keyword">return</span> sum(el1 != el2 <span class="keyword">for</span> el1, el2 <span class="keyword">in</span> zip(s1, s2))</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = x ^ y;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            i = i &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>特征点类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeyPoint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Point2f  pt;  <span class="comment">//坐标</span></span><br><span class="line">    <span class="keyword">float</span>  size; <span class="comment">//特征点邻域直径</span></span><br><span class="line">    <span class="keyword">float</span>  angle; <span class="comment">//特征点的方向，值为[零,三百六十)，负值表示不使用</span></span><br><span class="line">    <span class="keyword">float</span>  response;</span><br><span class="line">    <span class="keyword">int</span>  octave; <span class="comment">//特征点所在的图像金字塔的组</span></span><br><span class="line">    <span class="keyword">int</span>  class_id; <span class="comment">//用于聚类的id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存放匹配结果的结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DMatch</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//三个构造函数</span></span><br><span class="line">    DMatch():</span><br><span class="line">queryIdx(<span class="number">-1</span>),trainIdx(<span class="number">-1</span>),imgIdx(<span class="number">-1</span>),distance(<span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">float</span>&gt;::max()) &#123;&#125;</span><br><span class="line">    DMatch(<span class="keyword">int</span>  _queryIdx, <span class="keyword">int</span>  _trainIdx, <span class="keyword">float</span>  _distance ) :</span><br><span class="line">queryIdx( _queryIdx),trainIdx( _trainIdx), imgIdx(<span class="number">-1</span>),distance( _distance) &#123;&#125;</span><br><span class="line">    DMatch(<span class="keyword">int</span>  _queryIdx, <span class="keyword">int</span>  _trainIdx, <span class="keyword">int</span>  _imgIdx, <span class="keyword">float</span>  _distance ) :                   </span><br><span class="line">queryIdx(_queryIdx), trainIdx( _trainIdx), imgIdx( _imgIdx),distance( _distance) &#123;&#125;</span><br><span class="line">    intqueryIdx;  <span class="comment">//此匹配对应的查询图像的特征描述子索引</span></span><br><span class="line">    inttrainIdx;   <span class="comment">//此匹配对应的训练(模板)图像的特征描述子索引</span></span><br><span class="line">    intimgIdx;    <span class="comment">//训练图像的索引(若有多个)</span></span><br><span class="line">    <span class="keyword">float</span> distance;  <span class="comment">//两个特征向量之间的欧氏距离，越小表明匹配度越高。</span></span><br><span class="line">    booloperator &lt; (<span class="keyword">const</span> DMatch &amp;m) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/features2d/features2d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"usage: feature_extraction img1 img2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-- 读取图像</span></span><br><span class="line">Mat img_1 = imread(argv[<span class="number">1</span>]);<span class="comment">//, CV_LOAD_IMAGE_COLOR</span></span><br><span class="line">Mat img_2 = imread(argv[<span class="number">2</span>]);<span class="comment">//, CV_LOAD_IMAGE_COLOR</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//- 初始化detector检测器descriptor描述子matcher匹配器，并声明怕匹配使用汉明距离</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;KeyPoint&gt; keypoints_1, keypoints_2;</span><br><span class="line">Mat descriptors_1, descriptors_2;</span><br><span class="line">Ptr&lt;FeatureDetector&gt; detector = ORB::create();</span><br><span class="line">Ptr&lt;DescriptorExtractor&gt; descriptor = ORB::create();</span><br><span class="line">Ptr&lt;DescriptorMatcher&gt; matcher = DescriptorMatcher::create(<span class="string">"BruteForce-Hamming"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-- 第一步:检测 Oriented FAST 特征点位置</span></span><br><span class="line">detector-&gt;detect(img_1, keypoints_1);</span><br><span class="line">detector-&gt;detect(img_2, keypoints_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-- 第二步:计算特征点 BRIEF 描述子</span></span><br><span class="line">descriptor-&gt;compute(img_1, keypoints_1, descriptors_1);</span><br><span class="line">descriptor-&gt;compute(img_2, keypoints_2, descriptors_2);</span><br><span class="line"></span><br><span class="line">Mat outimg1;</span><br><span class="line">drawKeypoints(img_1, keypoints_1, outimg1, Scalar::all(<span class="number">-1</span>), DrawMatchesFlags::DEFAULT);</span><br><span class="line">imshow(<span class="string">"ORB特征点"</span>, outimg1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-- 第三步:对两幅图像中的BRIEF描述子进行匹配，使用 Hamming 距离</span></span><br><span class="line"><span class="comment">//-- 并创建DMatch对象存储匹配的结果</span></span><br><span class="line"><span class="built_in">vector</span>&lt;DMatch&gt; matches;</span><br><span class="line">matcher-&gt;match(descriptors_1, descriptors_2, matches);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-- 第四步:匹配点对筛选，设置匹配度的上下限的初始值，通过遍历描述子的距离更新为实际的上下限最值</span></span><br><span class="line"><span class="keyword">double</span> min_dist = <span class="number">10000</span>, max_dist = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找出所有匹配之间的最小距离和最大距离, 即是最相似的和最不相似的两组点之间的距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> dist = matches[i].distance;</span><br><span class="line"><span class="keyword">if</span> (dist &lt; min_dist) min_dist = dist;</span><br><span class="line"><span class="keyword">if</span> (dist &gt; max_dist) max_dist = dist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用max_element和min_element STL找出第一个最大（最小）值，与上边循环功能相同</span></span><br><span class="line">min_dist = min_element(matches.begin(), matches.end(), [](<span class="keyword">const</span> DMatch&amp; m1, <span class="keyword">const</span> DMatch&amp; m2) &#123;<span class="keyword">return</span> m1.distance &lt; m2.distance; &#125;)-&gt;distance;</span><br><span class="line">max_dist = max_element(matches.begin(), matches.end(), [](<span class="keyword">const</span> DMatch&amp; m1, <span class="keyword">const</span> DMatch&amp; m2) &#123;<span class="keyword">return</span> m1.distance &lt; m2.distance; &#125;)-&gt;distance;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-- Max dist : %f \n"</span>, max_dist);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-- Min dist : %f \n"</span>, min_dist);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当描述子之间的距离大于两倍的最小距离时,即认为匹配有误.但有时候最小距离会非常小,设置一个经验值30作为下限，进行限幅.</span></span><br><span class="line"><span class="comment">//将有效的匹配结果存入good_matches</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt; DMatch &gt; good_matches;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (matches[i].distance &lt;= max(<span class="number">2</span> * min_dist, <span class="number">30.0</span>))</span><br><span class="line">&#123;</span><br><span class="line">good_matches.push_back(matches[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-- 第五步:绘制匹配结果</span></span><br><span class="line">Mat img_match;</span><br><span class="line">Mat img_goodmatch;</span><br><span class="line">drawMatches(img_1, keypoints_1, img_2, keypoints_2, matches, img_match);</span><br><span class="line">drawMatches(img_1, keypoints_1, img_2, keypoints_2, good_matches, img_goodmatch);</span><br><span class="line">imshow(<span class="string">"所有匹配点对"</span>, img_match);</span><br><span class="line">imshow(<span class="string">"优化后匹配点对"</span>, img_goodmatch);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 算法 </category>
          
          <category> CV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回归常用评价指标</title>
      <link href="/2020/01/24/%E5%9B%9E%E5%BD%92%E5%B8%B8%E7%94%A8%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
      <url>/2020/01/24/%E5%9B%9E%E5%BD%92%E5%B8%B8%E7%94%A8%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<p>回归算法常用的评价指标：MSE，RMSE，MAE、R-Squared。</p><a id="more"></a><h1 id="均方误差（MES：Mean-Squared-Error）"><a href="#均方误差（MES：Mean-Squared-Error）" class="headerlink" title="均方误差（MES：Mean Squared Error）"></a>均方误差（MES：Mean Squared Error）</h1><p>$$ \frac{1}{m} \sum_{i=1}^{m} ({y_i}-\hat{y_i})^2$$<br>使用测试集上的值（真实值$y_i$）-预测值（$\hat{y_i}$），之后平方再取平均，经常会用在线性回归上做损失函数，因为他直接表示了预测值和真实值的误差大小，所以很适合来评估线性回归模型的准确度。  </p><h1 id="均方根误差（RMSE：Root-Mean-Squard-Error）"><a href="#均方根误差（RMSE：Root-Mean-Squard-Error）" class="headerlink" title="均方根误差（RMSE：Root Mean Squard Error）"></a>均方根误差（RMSE：Root Mean Squard Error）</h1><h2 id="本体"><a href="#本体" class="headerlink" title="本体"></a>本体</h2><p>$$ \sqrt{ \frac{1}{m} \sum_{i=1}^{m} ({y_i}-\hat{y_i})^2 }$$<br>MES开根号就是RMSE，但是为什莫要这么做呢？？？<br>为了让数据更好描述，为了输入和输出的数量级在同一个量级上，这样就可以直接在描述模型的时候说模型的误差是多少。  </p><h2 id="标准差（Standard-Deviation）"><a href="#标准差（Standard-Deviation）" class="headerlink" title="标准差（Standard Deviation）"></a>标准差（Standard Deviation）</h2><p>标准差是方差的算术平方根，也称均方差（mean square error），是各数据偏离平均数的距离的平均数，它是离均差平方和平均后的方根，用σ表示，标准差能反映一个数据集的离散程度。<br>$$<br>\begin{aligned}<br>    S^2 &amp;= \frac{1}{n} \sum_{i=1} ({x_i - \overline{X}}) ^2   \qquad \text{总体方差Var}  \\<br>    \sigma &amp;= \sqrt{\frac{1}{n} \sum_{i=1}^N (x_i - \mu)^2 }  \qquad \text{总体标准差SD}<br>\end{aligned}<br>$$</p><p>公式本体很像，SD更多应该是在统计中使用，均方根误差有的地方又叫标准误差（和标准差就差一个字，我人都傻了）更多是表征回归模型的结果，<strong><em>这个在下边拟合度R的计算中会体现出来</em></strong>。<br>统计中经常又不能对整个集合进行统计，所以又会有样本方差，和总体方差又不一样，他将分母换成了n-1，这个不再细说。</p><h1 id="平均绝对误差（MAE）"><a href="#平均绝对误差（MAE）" class="headerlink" title="平均绝对误差（MAE）"></a>平均绝对误差（MAE）</h1><p>$$  \frac{1}{m} \sum_{i=1}^{m} |{y_i}-\hat{y_i}|$$</p><h1 id="拟合度R平方（R-Squared）"><a href="#拟合度R平方（R-Squared）" class="headerlink" title="拟合度R平方（R Squared）"></a>拟合度R平方（R Squared）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>线性回归问题中，R-Squared 是用来衡量回归方程与真实样本输出之间的相似程度。  </p><p>在上边描述的几种评价指标中，根据不同的问题，可能会有不一样的结果。比如预测股票，每股价格误差结果可能是几十，预测人口增长误差结果可能是上万。那么如果有一个统一的评价标准来描述就可以很直观的对模型的准确性有一个认识，这时候就出现了拟合度R方这个东西，<strong>相当于一个归一化的过程</strong>。  </p><p>$$<br>\begin{aligned}<br>    R^2 = 1 - \frac{SS_{residual}}{SS_{total}}<br>\end{aligned}<br>$$  </p><p>其中分子是Residual Sum of Squares 分母是 Total Sum of Squares<br>$$ \begin{aligned}<br>    SS_{residual} &amp;= \sum_i {(y_i - \hat{y}_i)^2}  \\<br>    \quad SS_t &amp;= \sum_i {(y_i - \overline{y}_i)^2}<br>\end{aligned}$$</p><p>由以上各式很明显可以明白。  </p><p>分子是使用模型计算得到的误差，真实值与预测值的平方差之和，类似于均方差MSE。<br>分母是没有任何模型，按照平均值计算得到的误差（相当于瞎猜的结果），真实值与均值的平方差之和，类似于方差 Var（也叫偏估计）。<br>其实，上下同除n，就会发现分子变成了MSE，分母变成了Var。  </p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>根据 R-Squared 的取值，来判断模型的好坏：如果结果是 0，说明模型拟合效果很差；如果结果是 1，说明模型无错误。一般来说，R-Squared 越大，表示模型拟合效果越好。<br>R-Squared 反映的是大概有多准，因为，随着样本数量的增加，R-Square必然增加，无法真正定量说明准确程度，只能大概定量。</p><h1 id="协方差（Covariance）"><a href="#协方差（Covariance）" class="headerlink" title="协方差（Covariance）"></a>协方差（Covariance）</h1><p>协方差在概率论和统计学中用于衡量两个变量的总体误差。而方差是协方差的一种特殊情况。<br>如果两个变量的变化趋势一致，也就是说如果其中一个大于自身的期望值，另外一个也大于自身的期望值，那么两个变量之间的协方差就是正值，反之为负值，所以他表征了两个变量的总体误差。<br>$$<br>{cov(X,Y)} = \frac{ \sum_{i=1}^n  ( X_i - \overline{X} ) ( Y_i - \overline{Y} ) }{n-1}<br>$$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>scikit-learn中集成了很多工具，上边叙述的基本都可以直接调用方法实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error <span class="comment">#均方误差</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_absolute_error <span class="comment">#平方绝对误差</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score<span class="comment">#R square</span></span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line">mean_squared_error(y_test,y_predict)</span><br><span class="line">mean_absolute_error(y_test,y_predict)</span><br><span class="line">r2_score(y_test,y_predict)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/charlene_bo/article/details/70599183" target="_blank" rel="noopener">均方根值、均方根误差以及标准差</a><br><a href="https://blog.csdn.net/zrh_CSDN/article/details/81190001" target="_blank" rel="noopener">R-Squared</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 算法 </category>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KNN（K-近临）简述</title>
      <link href="/2020/01/19/KNN%EF%BC%88K-%E8%BF%91%E4%B8%B4%EF%BC%89%E7%AE%80%E8%BF%B0/"/>
      <url>/2020/01/19/KNN%EF%BC%88K-%E8%BF%91%E4%B8%B4%EF%BC%89%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>K-Nearest Neighbor algorithm简称KNN（K近邻算法），由名字来看就是依据原有数据之间的<code>距离</code>对新数据进行<code>分类</code>的一个算法。  </p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最简单的分类器可以将所有的数据对应的类别进行记录，在得到新数据时将数据的属性与已记录的数据进行匹配，当完全匹配时即可确定数据的类型。  </p><p>但是一般情况下不可能对所有可能的数据进行统计，所以这时候就出现了KNN这样基于数据统计的算法（其实绝大多数机器学习算法都是基于数据统计的）。  </p><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><p>KNN是通过对已知的样本特征值求距离进行分类的，即得到一个样本在特征空间中与其最相似（或者说最邻近）的K个样本，则这K个样本中最多的类型就认为是所求样本的特征值。  </p><p>下面通过一个简单的例子来说明一下（又是这张图）：  </p><img src="/2020/01/19/KNN（K-近临）简述/KNN.png">  <p>由图中我们可以看出在平面（特征空间）上共计由三类样本，我们将红色三角化为一类，将蓝色方块化为一类，绿色的圆作为待分类的样本，每个样本都有两个坐标（特征值），分别为x轴坐标和y轴坐标。真实的场景中这里可以是高维的特征空间和特征向量对应分类样本中可提取的特征值。接着看这张图，根据上边所说，将有一下两种情况：  </p><ul><li>若K = 3，则可以画出以绿色为圆心的第一条实线将三个最近的样本包括进来，则这时候我们则将圆划分为红色三角形的类别。  </li><li>同理，若K = 5，则蓝色的占3/5，这时候蓝色占多数，将圆形的样本分类为蓝色正方形。  </li></ul><p>总结起来就是几个步骤：</p><ul><li>求得待分类样本与数据集中所有样本的距离（一般我们用欧式距离或者曼哈顿距离）</li><li>将数据集中的样本按照距离由小到大排序，取前K个数据</li><li>统计前K个数据中各个类别出现的频率</li><li>频率出现最高的类别就可以认为是代求的样本的类别  <h1 id="欧式距离与曼哈顿距离"><a href="#欧式距离与曼哈顿距离" class="headerlink" title="欧式距离与曼哈顿距离"></a>欧式距离与曼哈顿距离</h1><h2 id="欧式距离"><a href="#欧式距离" class="headerlink" title="欧式距离"></a>欧式距离</h2>$$ d(X,Y)= \sqrt{\sum_{k=1}^{n}{(x_i-y_i)}^2} $$<br>欧式距离也称欧几里得距离，是最常见的距离度量，衡量的是多维空间中两个点之间的绝对距离。<br>也就是N维空间中两点间的真实距离，或向量的自然长度。  <h2 id="曼哈顿距离"><a href="#曼哈顿距离" class="headerlink" title="曼哈顿距离"></a>曼哈顿距离</h2>$$ d(X,Y)= \sqrt{\sum_{k=1}^{n}{|x_i-y_i|}} $$<br>曼哈顿距离，也称出租车距离，也就是在各个维度上的距离差之和。曼哈顿距离也是最简单的距离计算方法。  </li></ul><h1 id="K值的意义和选择"><a href="#K值的意义和选择" class="headerlink" title="K值的意义和选择"></a>K值的意义和选择</h1><h2 id="K的意义"><a href="#K的意义" class="headerlink" title="K的意义"></a>K的意义</h2><p>来了一个样本x，要给它分类，即求出它的y，就从数据集中，在x附近找离它最近的K个数据点，这K个数据点，类别c占的个数最多，就把x的label设为c  </p><h2 id="K值的选择"><a href="#K值的选择" class="headerlink" title="K值的选择"></a>K值的选择</h2><ol><li>如果选择较小的K值，就相当于用较小的领域中的训练实例进行预测，“学习”近似误差会减小，只有与输入实例较近或相似的训练实例才会对预测结果起作用，与此同时带来的问题是“学习”的估计误差会增大，换句话说，K值的减小就意味着整体模型变得复杂，容易发生过拟合；</li><li>如果选择较大的K值，就相当于用较大领域中的训练实例进行预测，其优点是可以减少学习的估计误差，但缺点是学习的近似误差会增大。这时候，与输入实例较远（不相似的）训练实例也会对预测器作用，使预测发生错误，且K值的增大就意味着整体的模型变得简单。</li><li>K=N，则完全不足取，因为此时无论输入实例是什么，都只是简单的预测它属于在训练实例中最多的类，模型过于简单，忽略了训练实例中大量有用信息。  </li></ol><p>在实际应用中，K值一般取一个比较小的数值，例如采用交叉验证法（简单来说，就是一部分样本做训练集，一部分做测试集）来选择最优的K值。</p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><p>python代码，在同一个目录下新建一个名为<code>KNN.xls</code>的表格，前两列作为特征值，第三列作为类别标签，之后可以直接运行脚本看到现象，或者也可以在命令行中使用方法生成样本。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> operator   <span class="comment">#内置的算数比较包</span></span><br><span class="line"><span class="keyword">import</span> xlrd    <span class="comment">#用于操作表格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##给出训练数据以及对应的类别</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    group = np.array([[<span class="number">1.0</span>,<span class="number">2.0</span>],[<span class="number">1.2</span>,<span class="number">0.1</span>],[<span class="number">0.1</span>,<span class="number">1.4</span>],[<span class="number">0.3</span>,<span class="number">3.5</span>]])</span><br><span class="line">    labels = [<span class="string">'A'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'B'</span>]</span><br><span class="line">    <span class="keyword">return</span> group,labels</span><br><span class="line"></span><br><span class="line"><span class="comment">###通过KNN进行分类</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify</span><span class="params">(input,dataSet,label,k)</span>:</span></span><br><span class="line">    dataSize = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">####计算欧式距离</span></span><br><span class="line">    diff = np.tile(input,(dataSize,<span class="number">1</span>)) - dataSet</span><br><span class="line">    sqdiff = diff ** <span class="number">2</span></span><br><span class="line">    squareDist = np.sum(sqdiff,axis = <span class="number">1</span>)<span class="comment">###行向量分别相加，从而得到新的一个行向量</span></span><br><span class="line">    dist = squareDist ** <span class="number">0.5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">##对距离进行排序</span></span><br><span class="line">    sortedDistIndex = np.argsort(dist)<span class="comment">##argsort()根据元素的值从大到小对元素进行排序，返回下标</span></span><br><span class="line"></span><br><span class="line">    classCount=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        voteLabel = label[sortedDistIndex[i]]</span><br><span class="line">        <span class="comment">###对选取的K个样本所属的类别个数进行统计</span></span><br><span class="line">        classCount[voteLabel] = classCount.get(voteLabel,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="comment">###选取出现的类别次数最多的类别</span></span><br><span class="line">    maxCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> classCount.items():</span><br><span class="line">        <span class="keyword">if</span> value &gt; maxCount:</span><br><span class="line">            maxCount = value</span><br><span class="line">            classes = key</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> classes</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    group = np.array([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>]],dtype=np.float)</span><br><span class="line">    labels = [<span class="string">'?'</span>,<span class="string">'?'</span>,<span class="string">'?'</span>,<span class="string">'?'</span>,<span class="string">'?'</span>,<span class="string">'?'</span>]</span><br><span class="line"></span><br><span class="line">    DataSet = xlrd.open_workbook(<span class="string">r'./KNN.xls'</span>)</span><br><span class="line">    sheet = DataSet.sheet_by_index(<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">"数据共："</span>,sheet.ncols,<span class="string">" 列"</span>,sheet.nrows,<span class="string">" 行"</span>)</span><br><span class="line">    print(group.shape[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(sheet.nrows):</span><br><span class="line">        group[i] = sheet.cell_value(i,<span class="number">0</span>),sheet.cell_value(i,<span class="number">1</span>)</span><br><span class="line">        labels[i] = sheet.cell_value(i,<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">"第 "</span>,i,<span class="string">" 行的数据为"</span>,group[i],<span class="string">"类别为"</span>,labels[i])</span><br><span class="line"></span><br><span class="line">    inputdata = eval(input(<span class="string">"please input your data ( separated by commas):"</span>))</span><br><span class="line">    K = eval(input(<span class="string">"input K value ："</span>)) <span class="comment">#eval 将输入时自动添加的""去掉</span></span><br><span class="line">    DataSet = np.array(inputdata)</span><br><span class="line">    output = classify(DataSet,group,labels,K)</span><br><span class="line">    print(<span class="string">"resout of the class is : "</span>,output)</span><br></pre></td></tr></table></figure><p>具体代码可以去我GitHub上看：<br><a href="https://github.com/qm-k/Algorithm_Getting_Started" target="_blank" rel="noopener">https://github.com/qm-k/Algorithm_Getting_Started</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 算法 </category>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CubeMX之EXTI</title>
      <link href="/2019/11/02/CubeMX%E4%B9%8BEXIT/"/>
      <url>/2019/11/02/CubeMX%E4%B9%8BEXIT/</url>
      
        <content type="html"><![CDATA[<p>使能一个中断，并通过按键控制LED亮灭。</p><a id="more"></a><p>这一章在<a href="https://www.qm-k.xyz/2019/10/25/CubeMX%E4%B9%8BGPIO/">CubeMX之GPIO</a>的基础上进行操作，复制整个工程之后，打开<code>.ico</code>（cubemx的工程文件）文件。<br>查看原理图，这里以我自己板子上的Key0为例，将PB9配置为GPIO_EXTI0模式。<br>Snipaste_2019-11-02_14-11-24.jpg 引脚定义<br>Snipaste_2019-11-02_14-15-57.jpg 配置PB9为GPIO_EXTI0模式<br>按键按下为低电平，松开为高电平，于是</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 嵌入式 </category>
          
          <category> CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式搬砖手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RTThread输出PWM失败原因</title>
      <link href="/2019/10/27/RTTread%E8%BE%93%E5%87%BAPWM%E5%A4%B1%E8%B4%A5%E5%8E%9F%E5%9B%A0/"/>
      <url>/2019/10/27/RTTread%E8%BE%93%E5%87%BAPWM%E5%A4%B1%E8%B4%A5%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<p>在STM32F407上移植PWM输出时，遇到了无法正常输出波形的问题，RT-Thread版本为4.0.2。  </p><a id="more"></a><p>经过筛查发现是由于定时器时钟没有开启导致的，需要在初始化PWM设备时对其挂载的总线时钟进行初始化。  </p><img src="/2019/10/27/RTTread输出PWM失败原因/Snipaste_2019-10-27_13-49-30.jpg"><p>打开<code>drv_pwm.c</code>文件，在PWM初始化中添加时钟初始化。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef BSP_USING_PWM2</span><br><span class="line">    __HAL_RCC_TIM2_CLK_ENABLE();</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>添加完是这个样子的：  </p><img src="/2019/10/27/RTTread输出PWM失败原因/Snipaste_2019-10-27_13-51-57.jpg">  <p>如果需要手工添加BSP可以参考：<br><a href="https://www.rt-thread.org/document/site/application-note/driver/pwm/an0037-rtthread-driver-pwm/" target="_blank" rel="noopener">STM32上使用PWM</a><br><a href="https://www.rt-thread.org/document/site/programming-manual/device/pwm/pwm/" target="_blank" rel="noopener">PWM设备</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 嵌入式 </category>
          
          <category> RTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式搬砖手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CubeMX之PWM</title>
      <link href="/2019/10/26/CubeMX%E4%B9%8BPWM/"/>
      <url>/2019/10/26/CubeMX%E4%B9%8BPWM/</url>
      
        <content type="html"><![CDATA[<p>使能一个PWM，并产生一个呼吸灯。  </p><a id="more"></a><p>脉冲宽度调制（PWM），是英文“Pulse Width Modulation”的缩写，简称脉宽调试。是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术。广泛应用在从测量、通信到功率控制与变换的许多领域中。<br>stm32中有定时器会不停的自加，直到等于Pulse值就会变为低电平，而当等于ARR寄存器(Period)的值时，定时器就会重新清零，不停的循环往复。<br>更详细的原理本文不再叙述，涉及到的PWM模式问题以及死区、DMA等等问题，之后单独开一篇文章讲述，这里不再叙述。<br>对于PWM更详细概念在<a href>PWM的概念</a>一节中进行叙述，这里只讲解如何使用。<br>同<a href="https://www.qm-k.xyz/2019/10/25/CubeMX%E4%B9%8BGPIO/">使能一个GPIO章节</a>的配置,创建工程、使能外部高速晶振、配置时钟树，最后打开Timers，选择要用来输出PWM的定时器，并选择要输出的通道，一般一个定时器都有四个通道(当然也有两通道的，或者不能用作输出的)：  </p><img src="/2019/10/26/CubeMX之PWM/Snipaste_2019-11-01_19-35-44.jpg">  <p>只有高级定时器可以输出PWM，普通定时器是不能输出的，这个在cubemx中可以很明确的看出来，像下面这个就是不能用作输出的，只能用作定时：  </p><img src="/2019/10/26/CubeMX之PWM/Snipaste_2019-11-01_19-39-15.jpg">  <p>下边主要讲一下配置PWM输出的参数：  </p><img src="/2019/10/26/CubeMX之PWM/Snipaste_2019-11-01_19-54-40.jpg">  <p>由于我使用的板子是F407的，配置系统时钟为168MHz，通过查看<code>stm32f407xx.h</code>，可以确定TIM1挂载在APB2,时钟频率为168MHz。  </p><img src="/2019/10/26/CubeMX之PWM/Snipaste_2019-11-01_20-02-10.jpg">  <img src="/2019/10/26/CubeMX之PWM/Snipaste_2019-11-01_20-08-50.jpg">  <p>此处设置为1680分频。经过分频后的时钟频率为100000Hz，若要设置PWM周期为20ms,则ARR寄存器的值为2000-1。其他参数为默认不用修改。其中Pulse的为设置脉宽，即为捕获/比较寄存器（TIMx_CCRx）。通过修改它的值可以修改占空比。</p><img src="/2019/10/26/CubeMX之PWM/Snipaste_2019-11-01_20-47-40.jpg">  <p>生成代码，添加应用程序：<br>在主函数中可以看到有<code>MX_TIM1_Init()</code>函数，右键<code>go to definition</code>,可以看到初始化函数(固件库版本不同可能不一致，但是不影响，原理一样)：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/* TIM1 init function */</span><br><span class="line">void MX_TIM1_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">  TIM_MasterConfigTypeDef sMasterConfig = &#123;0&#125;;</span><br><span class="line">  TIM_OC_InitTypeDef sConfigOC = &#123;0&#125;;</span><br><span class="line">  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">  htim1.Instance = TIM1;</span><br><span class="line">  htim1.Init.Prescaler = 1680-1;</span><br><span class="line">  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;</span><br><span class="line">  htim1.Init.Period = 20000-1;          //这里为了让波形更明显调大了值，真实使用不会这莫大，要根据实际的控制频率来设置</span><br><span class="line">  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;</span><br><span class="line">  htim1.Init.RepetitionCounter = 0;</span><br><span class="line">  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;</span><br><span class="line">  if (HAL_TIM_PWM_Init(&amp;htim1) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;</span><br><span class="line">  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;</span><br><span class="line">  if (HAL_TIMEx_MasterConfigSynchronization(&amp;htim1, &amp;sMasterConfig) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//就是这一段，很重要</span><br><span class="line">  sConfigOC.OCMode = TIM_OCMODE_PWM1;</span><br><span class="line">  sConfigOC.Pulse = 0;</span><br><span class="line">  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;</span><br><span class="line">  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;</span><br><span class="line">  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;</span><br><span class="line">  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;</span><br><span class="line">  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;</span><br><span class="line">  if (HAL_TIM_PWM_ConfigChannel(&amp;htim1, &amp;sConfigOC, TIM_CHANNEL_1) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;</span><br><span class="line">  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;</span><br><span class="line">  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;</span><br><span class="line">  sBreakDeadTimeConfig.DeadTime = 0;</span><br><span class="line">  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;</span><br><span class="line">  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;</span><br><span class="line">  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;</span><br><span class="line">  if (HAL_TIMEx_ConfigBreakDeadTime(&amp;htim1, &amp;sBreakDeadTimeConfig) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">  HAL_TIM_MspPostInit(&amp;htim1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边那一串代码中用注释框起来的代码就是我们在应用程序中要用的代码了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void user_pwm_setvalue(uint16_t value)</span><br><span class="line">&#123;</span><br><span class="line">    TIM_OC_InitTypeDef sConfigOC;</span><br><span class="line">    sConfigOC.OCMode = TIM_OCMODE_PWM1;</span><br><span class="line">    sConfigOC.Pulse = value;                //Pulse就是用于修改脉冲宽度的变量，其他的直接照着初始化代码复制即可</span><br><span class="line">    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;</span><br><span class="line">    sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;</span><br><span class="line">    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;</span><br><span class="line">    sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;</span><br><span class="line">    sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;</span><br><span class="line">    if (HAL_TIM_PWM_ConfigChannel(&amp;htim1, &amp;sConfigOC, TIM_CHANNEL_1) != HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">      Error_Handler();</span><br><span class="line">    &#125;</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim1, TIM_CHANNEL_1);//开启PWM输出，在cubemx自动生成的初始化中是</span><br><span class="line">                                             //不会默认使能输出的，这一点一定要注意  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main()函数中添加HAL_TIM_PWM_Start(&amp;htim4, TIM_CHANNEL_1)开启定时器PWM输出。在while循环中不断修改脉宽</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> /* Initialize all configured peripherals */</span><br><span class="line"> MX_GPIO_Init();</span><br><span class="line"> MX_TIM1_Init();</span><br><span class="line"> /* USER CODE BEGIN 2 */</span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim1,TIM_CHANNEL_1);</span><br><span class="line"> /* USER CODE END 2 */</span><br><span class="line"></span><br><span class="line"> /* Infinite loop */</span><br><span class="line"> /* USER CODE BEGIN WHILE */</span><br><span class="line"> while (1)</span><br><span class="line"> &#123;</span><br><span class="line">   /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">   /* USER CODE BEGIN 3 */</span><br><span class="line">HAL_Delay(10);                  //如果要呼吸灯效果是不能这么短的延时的，这个延时长度只是为了让波形更明显</span><br><span class="line">if(pwm_value == 0) step = 500;</span><br><span class="line">if(pwm_value == 20000) step = -500; //这里同样是为了让波形更明显</span><br><span class="line">pwm_value += step;</span><br><span class="line">user_pwm_setvalue(pwm_value);</span><br><span class="line"> &#125;</span><br><span class="line"> /* USER CODE END 3 */</span><br></pre></td></tr></table></figure><p>此时可以对输出引脚进行测量，如果不知道是哪一个引脚可以看CubeMX右侧的Pinout view，这里不再叙述，方法很多。<br>如果所有操作没问题，就可以看到：</p><img src="/2019/10/26/CubeMX之PWM/ADS00003.BMP">  <p>此时在对应管脚上接入一个led就可以看到呼吸灯的效果(此时应修改上边几处标注的值才会有一个好效果)。<br>会出现像下边这样比较规则且逐渐增大的波形：</p><img src="/2019/10/26/CubeMX之PWM/ADS00002.BMP">  ]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 嵌入式 </category>
          
          <category> CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式搬砖手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CubeMX之GPIO</title>
      <link href="/2019/10/25/CubeMX%E4%B9%8BGPIO/"/>
      <url>/2019/10/25/CubeMX%E4%B9%8BGPIO/</url>
      
        <content type="html"><![CDATA[<p>使能一个GPIO，并点亮第一个LED。</p><a id="more"></a><ol><li>打开cubemx，并新建一个cubemx工程：<img src="/2019/10/25/CubeMX之GPIO/Snipaste_2019-10-25_10-31-05.png">  <img src="/2019/10/25/CubeMX之GPIO/Snipaste_2019-10-25_10-41-19.png">  </li><li>使能外部高速晶振<br>选择晶体/陶瓷 谐振器，和震荡器的区别是这个是无源的。<img src="/2019/10/25/CubeMX之GPIO/Snipaste_2019-10-25_10-54-26.png">  </li><li>打开淘宝随便买一块板子并索要原理图<br>一般c8t6的板子都在10元到20元左右，打开原理图，找到板子上的灯接在哪个引脚上。<img src="/2019/10/25/CubeMX之GPIO/Snipaste_2019-10-25_10-48-10.png">  像我手里随便找了个板子，原理图上显示led接在PB12端口上，设置PB12引脚为输出模式，直接点击要设置的引脚就能直接选择工作模式。<img src="/2019/10/25/CubeMX之GPIO/Snipaste_2019-10-25_10-56-27.png">  </li><li>配置时钟树<br>AHB总线的最高速度CubeMX会在框下面提示。<img src="/2019/10/25/CubeMX之GPIO/Snipaste_2019-10-25_11-01-00.png">   没错的话会变成这样：  <img src="/2019/10/25/CubeMX之GPIO/Snipaste_2019-10-25_11-01-34.png">  </li><li>设置GPIO的属性<br>因为led要输出的，要配置为低速推挽输出模式，既不上拉也不下拉，所以可以保持默认的模式不用配置。  <img src="/2019/10/25/CubeMX之GPIO/Snipaste_2019-10-25_11-02-52.png">  </li><li>设置工程输出属性<img src="/2019/10/25/CubeMX之GPIO/Snipaste_2019-10-25_11-05-56.png">  设置代码生成的方式<img src="/2019/10/25/CubeMX之GPIO/Snipaste_2019-10-25_11-09-04.png">  </li><li>生成并打开代码工程<img src="/2019/10/25/CubeMX之GPIO/Snipaste_2019-10-25_11-11-18.png">  在main.c中while(1)中最后面的USER CODE BEGIN 3和USER CODE END 3中间添加如下内容。<br>（用户代码要加在USER CODE BEGIN N和USER CODE END N之间，否则下次重新生成代码后，会被删除）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_RESET);<span class="comment">//led pin reset</span></span><br><span class="line">HAL_Delay(<span class="number">1000</span>);<span class="comment">//This function provides minimum delay (in milliseconds) based on variable incremented.</span></span><br><span class="line">HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_SET);<span class="comment">//led pin set</span></span><br><span class="line">HAL_Delay(<span class="number">1000</span>);<span class="comment">//This function provides minimum delay (in milliseconds) basedon variable incremented.</span></span><br></pre></td></tr></table></figure></li></ol><p>之后选择编译下载就可以看到led周期为1S进行闪烁了。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 嵌入式 </category>
          
          <category> CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式搬砖手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CubeMX的安装</title>
      <link href="/2019/10/25/CubeMX%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/10/25/CubeMX%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">让所有人有机会成为Maker，之后再想办法成为Learner</blockquote><p>意法半导体的一系列软件工具让嵌入式工程师变成了大白菜，只需要点点点就能把硬件配置完成，让用户只关注于软件逻辑，再加上越来越成熟的HAL库，软件在不同硬件上的区别越来越小，可扩展性和可移植性都越来越强。下边从CubeMX的安装开始，逐步讲解STM系列的使用。</p><a id="more"></a><p>现在ST公司升级和维护的库主要就是STM32CubeMX的HAL库和标准外设库，而STM32CubeMX是一个配置STM32代码的工具，它把很多东西封装的比较好，硬件抽象层（HAL）、中间层、示例代码等。  </p><p>整个软件非常现代化，有很直观的资源提示，在配置冲突的情况下有很直观的错误信息，可视化的端口配置与时钟树配置，对快速上手并理解单片机非常友好。  </p><p>登录ST<a href="https://www.st.com/content/st_com/en.html" target="_blank" rel="noopener">官网</a>,在产品展示（Products）中直接搜索CubeMX，可以搜到STM8的，还有STM32的，根据需要选择，找不到的话直接点<a href="https://www.st.com/content/st_com/en/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-configurators-and-code-generators/stm32cubemx.html" target="_blank" rel="noopener">这里</a>进行登录，然后点<code>Get Software</code>填一下个人邮箱信息，会把下载链接发到邮箱。  </p><img src="/2019/10/25/CubeMX的安装/Getsoftware.png">  <p>因为CubeMX是基于Java的，所以还需要安装一下Java，安装<a href="https://www.java.com/zh_CN/download/win10.jsp" target="_blank" rel="noopener">链接</a>,下载后一直点确定就行，可能安装的时候会自动下载东西，网差的话多试几次。  </p><img src="/2019/10/25/CubeMX的安装/Java.png">  <p>安装好之后还需要安装使用的芯片对应的芯片包。这个可以在软件内进行安装也可以在网站上单独下载安装包进行安装，一般在软件内安装更方便一些，但是对网络要求更高一点，需要科学上网，具体过程如下：</p><ul><li>打开CUBEMX，打开包管理器：<img src="/2019/10/25/CubeMX的安装/manage.png">  </li><li>选择要用的芯片：  <img src="/2019/10/25/CubeMX的安装/pack1.png">  <img src="/2019/10/25/CubeMX的安装/pack2.png">  </li></ul><p>安装好后就可以开始工程了。<br>所有过程中的路径一定不要有中文，如果遇到无法生成代码的问题，很大可能就是中文路径或者是权限不足导致的。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 嵌入式 </category>
          
          <category> CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式搬砖手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NCHW与NHWC</title>
      <link href="/2019/10/14/NCHW%E4%B8%8ENHWC/"/>
      <url>/2019/10/14/NCHW%E4%B8%8ENHWC/</url>
      
        <content type="html"><![CDATA[<p>在使用NPU的过程中会遇到要将npu输出的一维数据重新<code>reshape</code>成正常的表示图像大小、通道数、以及图片数量的数据格式，这时候有两种常用的顺序可以使用<code>NCHW</code>、<code>NHWC</code>。  </p><a id="more"></a><table><thead><tr><th align="center">N</th><th align="center">一个batch内图片的数量</th></tr></thead><tbody><tr><td align="center">C</td><td align="center">通道数channel。例如灰度图像为1， 彩色RGB图像为3</td></tr><tr><td align="center">H</td><td align="center">垂直高度方向的像素个数</td></tr><tr><td align="center">W</td><td align="center">水平宽度方向的像素个数</td></tr></tbody></table><h1 id="改变维度顺序"><a href="#改变维度顺序" class="headerlink" title="改变维度顺序"></a>改变维度顺序</h1><p>例如现在有一个张量如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [[[  1,   2],</span><br><span class="line">      [  3,   4]],</span><br><span class="line">     [[ 5,  6],</span><br><span class="line">      [ 7,  8]],</span><br><span class="line">     [[9, 10,</span><br><span class="line">      [11, 12]]]</span><br></pre></td></tr></table></figure><p>此时他的shape即为（3，2，2），可以通过<code>x[0,:,:]</code>将第一个维度的值输出出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x[0, :, :]</span><br><span class="line">&lt;tf.Tensor: id=7, shape=(2, 2), dtype=int32, numpy=</span><br><span class="line">array([[1, 2],</span><br><span class="line">       [3, 4]], dtype=int32)&gt;</span><br></pre></td></tr></table></figure><p>为什莫要讨论其中某一个维度的位置呢？这个会在下边两种存储方式优劣的对比上体现出来，主要会在访存上体现出差别。  </p><p>如果需要切换通道顺序可以使用<code>tf.transpose</code>如果是numpy变量可以使用<code>np.transpose</code>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = tf.transpose(x, [1, 2, 0]) #第一个是参数要切换顺序的张量，第二个参数是改变后的通道顺序  </span><br><span class="line">#数字是原始张量中的维度编号，如原来的第一维0维现在是最后一维</span><br></pre></td></tr></table></figure><h1 id="将输出的一维结果转换为所需维度"><a href="#将输出的一维结果转换为所需维度" class="headerlink" title="将输出的一维结果转换为所需维度"></a>将输出的一维结果转换为所需维度</h1><p>各种加速棒或者npu、kpu计算的结果是一维的张量，需要将结果转化为正常的维度才能使用  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output = output.reshape(1, 57, 46, 46)</span><br></pre></td></tr></table></figure><p>比如使用RK的1808NPU进行加速：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">frame = cv2.resize(frame, (inWidth, inHeight), interpolation=cv2.INTER_CUBIC)</span><br><span class="line">if not hasFrame:</span><br><span class="line">    cv2.waitKey()</span><br><span class="line">    break</span><br><span class="line">frameWidth = frame.shape[1]</span><br><span class="line">frameHeight = frame.shape[0]</span><br><span class="line"></span><br><span class="line"># input mode转为’nchw’</span><br><span class="line">frame_input = np.transpose(frame, [2, 0, 1])</span><br><span class="line">t = time.time()</span><br><span class="line">[output] = rknn.inference(inputs=[frame_input], data_format=&quot;nchw&quot;)</span><br><span class="line">print(&quot;time:&quot;, time.time()-t)</span><br><span class="line">   </span><br><span class="line"># rknn输出的数组转为1x57x46x46的矩阵</span><br><span class="line">output = output.reshape(1, 57, 46, 46)</span><br></pre></td></tr></table></figure><h1 id="两种存储方式的优劣对比"><a href="#两种存储方式的优劣对比" class="headerlink" title="两种存储方式的优劣对比"></a>两种存储方式的优劣对比</h1><img src="/2019/10/14/NCHW与NHWC/all.png">  <p>由于数据存储是按张量最深层的维度进行依次遍历的就像下图这样存储：</p><img src="/2019/10/14/NCHW与NHWC/diff.png">  <p><strong>在NCHW的存储方式下，每一张图片都由W通道开始存储，也就是从一行的最左端存储到最右端，之后H通道加1，存储下一行，直到整个R通道存储完毕，通道数加1，存储G通道，一直存储到这张图片结束（为了方便，每一个通道我都只画了2x2个像素），而NHWC则先遍历存储通道，将一个图片坐标下的RGB通道遍历存储完之后再存储下一个坐标上的三个通道，两种存储方式都是最后再遍历一个batch内的图片张数（将前一张全部存储完毕后存储下一张）。</strong> </p><p>深度学习中涉及大量的数据计算,计算需要从内存中取出数据,因此需要计算出数据的偏移地址以便进行取数。  </p><p>那么根据以上分析，可以定义位置(n,c,h,w)表示第n个batch的第c通道的第h行的第w列,那么该位置在不同数据格式下,在内存中的偏移地址计算公式如下:<br>NCHW: offset_nchw(n, c, h, w) = n * CHW + c * HW + h * W + w<br>NHWC: offset_nhwc(n, c, h, w) = n * HWC + h * WC + w * C + c<br>CHWN: offset_chwn(n, c, h, w) = c * HWN + h * WN + w * N + n  </p><p>其中N、C、H、W为常量表示各个通道的最大值,n、c、h、w为变量表示当前位置的高维坐标。  </p><p>在NCHW中,CHW=C*H*W,表示一个Batch,可以理解成一个BGR 3通道的图片,表达的是一个立方体。HW=H*W,表示一个平面,可以理解成是BGR3通道图片的一个通道(灰度图就是一个通道图片)。W是一行,可以理解成一个通道上的一行。  </p><img src="/2019/10/14/NCHW与NHWC/toggle_movement.gif">  <p>结合上边加粗部分的论述和上图卷积过程的特点，两种计算方式的过程如下：  </p><p>先通道后像素:先把一个像素点的所有通道数与卷积的参数相乘后累加,再进行下一个像素,直到卷积核窗口乘累加完成。比如第一次滑窗的计算公式<br>(w0,0,0)*(x0,0,0) + (w1,0,0)*(x1,0,0) + (w2,0,0)*(x2,0,0) + (w0,0,1)*(x0,0,1) + (w1,0,1)*(x1,0,1) + (w2,0,1)*(x2,0,1) + (w0,0,2)*(x0,0,2) + (w1,0,1)*(x1,0,2) + (w2,0,2)*(x2,0,2) + (w0,1,0)*(x0,1,0) + (w1,1,0)*(x1,1,0) + (w2,1,0)*(x2,1,0) + (w0,1,1)*(x0,1,1) + (w1,1,1)*(x1,1,1) + (w2,1,1)*(x2,1,1) + (w0,1,2)*(x0,1,2) + (w1,1,1)*(x1,1,2) + (w2,1,2)*(x2,1,2) + (w0,2,0)*(x0,2,0) + (w1,2,0)*(x1,2,0) + (w2,2,0)*(x2,2,0) + (w0,2,1)*(x0,2,1) + (w1,2,1)*(x1,2,1) + (w2,2,1)*(x2,2,1) + (w0,2,2)*(x0,2,2) + (w1,2,1)*(x1,2,2) + (w2,2,2)*(x2,2,2) = 0*-1 + 0*-1 + 0*0 + 0*1 + 0*-1 + 0*0 + 0*0 + 0*0 + 0*-1 + 0*0 + 0*0 + 0*0 + 0*1 + 1*0 + 2*1 + 1*0 + 0*0 +1*0 + 0*0 + 0*0 + 0*1 + 2*1 + 0*-1 + 1*-1 + 2*1 + 0*0 + 0*-1 = 5</p><p>　　先像素后通道:先把一个通道滑动窗口与卷积参数相乘后累加,再进行下一个通道,直到所有通道乘累加完成。比如第一次滑窗计算公式<br>(w0,0,0)*(x0,0,0) + (w0,0,1)*(x0,0,1) + (w0,0,2)*(x0,0,2) + (w0,1,0)*(x0,1,0) + (w0,1,1)*(x0,1,1) + (w0,0,2)*(x0,1,2) + (w0,2,0)*(x0,2,0) + (w0,0,1)*(x0,2,1) + (w0,0,2)*(x0,2,2) + (w1,0,0)*(x1,0,0) + (w1,0,1)*(x1,0,1) + (w1,0,2)*(x1,0,2) + (w1,1,0)*(x1,1,0) + (w1,1,1)*(x1,1,1) + (w1,0,2)*(x1,1,2) + (w1,2,0)*(x1,2,0) + (w1,0,1)*(x1,2,1) + (w1,0,2)*(x1,2,2) + (w2,0,0)*(x2,0,0) + (w2,0,1)*(x2,0,1) + (w2,0,2)*(x2,0,2) + (w2,1,0)*(x2,1,0) + (w2,1,1)*(x2,1,1) + (w2,0,2)*(x2,1,2) + (w2,2,0)*(x2,2,0) + (w2,0,1)*(x2,2,1) + (w2,0,2)*(x2,2,2) = 0*-1 + 0*1 + 0*0 + 0*0 +0*1 + 1*0 + 0*0 + 2*1 + 2*1 + 0*-1 + 0*-1 + 0*0 + 0*0 + 1*0 + 0*0 + 0*0 + 0*-1 + 0*0 + 0*0 + 0*0 + 0*-1 + 0*0 + 2*1 + 1*0 + 0*1 + 1*-1 + 0*-1 = 5  </p><p>两种计算的结果并没有差别，但是在存取次数上就有了明显的差别了。<br>对于NHWC格式,即先通道后像素,是把一个像素的所有通道的数据放在一起。这样对应上图第一个像素的3个通道值,第二个像素的3个通道值,第三个像素的3个通道值,它们在内存中的地址都是连续的,也就是说一次就可以把kernel第一行需要计算的数取出,3x3的kernel需要3次取数。</p><p>　　而对于NCHW格式,即先像素后通道,是把一个通道的所有像素按顺序排列,这样对于一个3*3的卷积核,需要每取3个数就需要跳跃n个数后,再取3个数。一个通道需要取3次,3个通道需要取9次。<br>在实际网络中,通常通道数会远大于卷积kernel数(不会像上图只有3个通道,通常是几十、几百个通道)。这样对于NHWC格式来说说,取数的次数会比NCHW少很多。  </p><p>同时在做图像的灰度化的过程中也是同样的道理，由于NHWC的同一坐标下像素是在内存中连续存储的，所以NHWC的访存局部性更好（每三个输入像素即可得到一个输出像素），NCHW 则必须等所有通道全部读取完毕才能得到最终输出结果，需要占用较大的临时空间。  </p><img src="/2019/10/14/NCHW与NHWC/NHWC.png">  <h1 id="存储格式在不同设备上的区别"><a href="#存储格式在不同设备上的区别" class="headerlink" title="存储格式在不同设备上的区别"></a>存储格式在不同设备上的区别</h1><p>但是由于CPU是基于延迟优化的，而GPU是基于带宽优化的，所以，在不同的设备上两种存储方式各有优势，虽然NCHW格式需要更大的内存更多的存取次数，但是在GPU这种具有大量流处理器、高带宽的设备上高内存操作复杂度、多次重复的简单运算就会具有很大的优势，一般好的CPU大约能达到50GB/s的内存带宽，而好的GPU能达到750GB/s的内存带宽，CPU更擅长的是快速获取少量的内存，这时候NHWC就显得有优势。<br>早期的tensorflow采用NHWC格式就是因为早期的开发多数是基于CPU的，cache的利用效率更高，之后GPU高速发展之后NCHW格式就开始大规模使用，像常用的Nvidia cuDNN就是默认使用NCHW格式进行读写的。<br>参考：<br><a href="https://www.cnblogs.com/AIBOOM/p/11497507.html" target="_blank" rel="noopener">AIBOOM的blog</a><br><a href="https://blog.csdn.net/weixin_37801695/article/details/86614566" target="_blank" rel="noopener">RLilyX的blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 算法 </category>
          
          <category> ML </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kconfig的语法</title>
      <link href="/2019/10/13/Kconfig%E7%9A%84%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/10/13/Kconfig%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>内核在编译的时候会遍历每一个目录下的所有的Makefile文件，来决定编译哪个文件，确定文件的依赖关系。而Makefile会根据Kconfig来生成，也就是说，Kconfig配置了哪些文件编译，哪些文件不编译。  </p><a id="more"></a><table><thead><tr><th align="center">文件</th><th align="center">位置</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">Kconfig</td><td align="center">每个源码目录下</td><td align="center">提供选项</td></tr><tr><td align="center">.config</td><td align="center">源码顶层目录下</td><td align="center">保存选择结果</td></tr><tr><td align="center">Makefile</td><td align="center">每个源码目录下</td><td align="center">根据.config中的内容来告知编译系统如何编译</td></tr></tbody></table><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>Kconfig中每一个config就是一个选项，最上面跟着控制句柄，下面则是对这个选项的配置，如选项名是什么，依赖什么，选中这个后同时会选择什么。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">config SOC_STM32F103C8</span><br><span class="line">    bool  &quot;select SOC&quot;</span><br><span class="line">    select SOC_SERIES_STM32F1</span><br><span class="line">    select RT_USING_COMPONENTS_INIT</span><br><span class="line">    select RT_USING_USER_MAIN</span><br><span class="line">    default y</span><br><span class="line">    help</span><br><span class="line">        config SOC</span><br></pre></td></tr></table></figure><p>比如上边这一段,假设其目录为<code>bsp/SOC/.</code>，可以在同级目录的Makefile下能找到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj-$(SOC_STM32F103C8) += xxx.o</span><br><span class="line">/*</span><br><span class="line">Obj-$(CONFIG_选项名) += xxx.o </span><br><span class="line">当CONFIG_选项名=y时，表示对应目录下的xxx.c将被编译进内核</span><br><span class="line">当CONFIG_选项名=m时对应目录下的xxx.c将被编译成模块</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>而在上一级目录<code>bsp/.</code>中就会发现有一个Makefile中有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-y           += SOC/</span><br></pre></td></tr></table></figure><p>确保SOC目录下的文件能参与编译。</p><p><code>bsp/.</code>的Kconfig中有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">menu &quot;SOC_select&quot;</span><br><span class="line">source &quot;bsp/SOC/Kconfig&quot;</span><br></pre></td></tr></table></figure><p>以便上一级的Kconfig能检索到下一级的的Kconfig，在menuconfig中生成目录。</p><h1 id="Kconfig语法"><a href="#Kconfig语法" class="headerlink" title="Kconfig语法"></a>Kconfig语法</h1><p>由上边的例子不难看出，在menuconfig中更改的就是config后边句柄(SOC_STM32F103C8)的值，来确定后边的<code>xxx.o</code>是否生成，也就是说能控制<code>xxx.c</code>或<code>xxx.cpp</code>能否被编译。<br>这个是他的最基本的功能，而剩下的功能列一个表出来就是这个样子的：  </p><table><thead><tr><th align="center">内容</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">config</td><td align="center">选项</td></tr><tr><td align="center">SOC_STM32F103C8</td><td align="center">句柄，可用于控制Makefile选择是否编译</td></tr><tr><td align="center">bool</td><td align="center">TRUE选中句柄的值为y、FALSE不选句柄的值为n 选中则编译，不选中则不编译。（如果后面没有字符串名称，则表示其不会出现在选择软件列表中）</td></tr><tr><td align="center">select</td><td align="center">当前选项选中后则select后指定的选项自动被选择</td></tr><tr><td align="center">default</td><td align="center">值的默认情况</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">depends on BSP_USING_UART1 &amp;&amp; RT_SERIAL_USING_DMA</span><br></pre></td></tr></table></figure><p>depend on 依赖，后面的四个选择全被选上，这个选项才能被选</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">depends on BSP_USING_UART1 || RT_SERIAL_USING_DMA</span><br></pre></td></tr></table></figure><p>反之<br>后面的四个选择其中至少一个被选择，这个选项才能被选</p><h2 id="当选项不是布尔型而是数字时"><a href="#当选项不是布尔型而是数字时" class="headerlink" title="当选项不是布尔型而是数字时"></a>当选项不是布尔型而是数字时</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">config ARM_DMA_IOMMU_ALIGNMENT</span><br><span class="line">    int &quot;Maximum PAGE_SIZE order of alignment for DMA IOMMU buffers&quot; ----&gt;该选项是一个整型值</span><br><span class="line">    range 4 9 ----&gt;该选项的范围值</span><br><span class="line">    default 8 ----&gt;该选项的默认值</span><br><span class="line">    help</span><br><span class="line">      DMA mapping framework by default aligns all buffers to the smallest</span><br></pre></td></tr></table></figure><h2 id="由编译的前置条件"><a href="#由编译的前置条件" class="headerlink" title="由编译的前置条件"></a>由编译的前置条件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if ARCH_RISC_V ---&gt;若ARCH_64选项选中了，下边的才会有机会</span><br><span class="line"></span><br><span class="line">config CPU_k210</span><br><span class="line">    bool &quot;选项名&quot;</span><br><span class="line">    help</span><br><span class="line">      Enable k210 CPU support</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure><h2 id="做环境变量"><a href="#做环境变量" class="headerlink" title="做环境变量"></a>做环境变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config BSP_DIR</span><br><span class="line">    string</span><br><span class="line">    option env=&quot;BSP_ROOT&quot;</span><br><span class="line">    default &quot;.&quot;</span><br></pre></td></tr></table></figure><p>设置BSP_DIR的值。</p><h2 id="多个选项"><a href="#多个选项" class="headerlink" title="多个选项"></a>多个选项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">choice      ---&gt;表示选择列表</span><br><span class="line">    prompt &quot;Default I/O scheduler&quot;         //主目录名字</span><br><span class="line">    default DEFAULT_CFQ                    //默认CFQ</span><br><span class="line">    help</span><br><span class="line">      Select the I/O scheduler which will be used by default for all</span><br><span class="line">      block devices.</span><br><span class="line"></span><br><span class="line">    config DEFAULT_DEADLINE</span><br><span class="line">        bool &quot;Deadline&quot; if IOSCHED_DEADLINE=y </span><br><span class="line"></span><br><span class="line">    config DEFAULT_CFQ</span><br><span class="line">        bool &quot;CFQ&quot; if IOSCHED_CFQ=y</span><br><span class="line"></span><br><span class="line">    config DEFAULT_NOOP</span><br><span class="line">        bool &quot;No-op&quot;</span><br><span class="line"></span><br><span class="line">endchoice</span><br></pre></td></tr></table></figure><p>在这些选项中选择一个。</p><h2 id="menu"><a href="#menu" class="headerlink" title="menu"></a>menu</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu &quot;Onboard Peripheral Drivers&quot; //menu说明是不可选的菜单，其后为其菜单名</span><br><span class="line"></span><br><span class="line">    config BSP_USING_USB_TO_USART</span><br><span class="line">        bool &quot;Enable USB TO USART (uart1)&quot;</span><br><span class="line">        select BSP_USING_UART</span><br><span class="line">        select BSP_USING_UART1</span><br><span class="line">        default y</span><br><span class="line"></span><br><span class="line">endmenu ----&gt; menu菜单结束</span><br></pre></td></tr></table></figure><img src="/2019/10/13/Kconfig的语法/menu.png"><p>打开menu之后：</p><img src="/2019/10/13/Kconfig的语法/select_menu.png"><h2 id="menuconfig"><a href="#menuconfig" class="headerlink" title="menuconfig"></a>menuconfig</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">menuconfig BSP_USING_UART</span><br><span class="line">    bool &quot;Enable UART&quot;</span><br><span class="line">    default y</span><br><span class="line">    select RT_USING_SERIAL</span><br><span class="line">    if BSP_USING_UART</span><br><span class="line">        config BSP_USING_UART1</span><br><span class="line">            bool &quot;Enable UART1&quot;</span><br><span class="line">            default y</span><br><span class="line"></span><br><span class="line">        config BSP_UART1_RX_USING_DMA</span><br><span class="line">            bool &quot;Enable UART1 RX DMA&quot;</span><br><span class="line">            depends on BSP_USING_UART1 &amp;&amp; RT_SERIAL_USING_DMA</span><br><span class="line">            default n</span><br><span class="line">    endif</span><br></pre></td></tr></table></figure><p>只有选中了才能进入的目录。</p><img src="/2019/10/13/Kconfig的语法/menuconfig.png"><p>打开后：</p><img src="/2019/10/13/Kconfig的语法/select_menu.png">]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux查看局域网下所有主机IP</title>
      <link href="/2019/10/11/linux%E6%9F%A5%E7%9C%8B%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8B%E6%89%80%E6%9C%89%E4%B8%BB%E6%9C%BAIP/"/>
      <url>/2019/10/11/linux%E6%9F%A5%E7%9C%8B%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8B%E6%89%80%E6%9C%89%E4%B8%BB%E6%9C%BAIP/</url>
      
        <content type="html"><![CDATA[<p>在Linux下使用nmap工具对局域网扫描，可以通过查看arp缓存表就可以知道局域网内所有设备的IP和MAC地址。</p><a id="more"></a><ol><li><p>安装nmap：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install nmap</span><br></pre></td></tr></table></figure></li><li><p>输入指令进行查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sP 172.20.10.0/24</span><br></pre></td></tr></table></figure></li></ol><p>这条指令是以ping的方式进行扫描。<br>还可以用UDP ping  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -PU 172.20.10.0/24</span><br></pre></td></tr></table></figure><p>SYN扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS 172.20.10.0/24</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>A*寻路算法</title>
      <link href="/2019/10/07/A-%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2019/10/07/A-%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">虽天下之大，大可去得</blockquote><p>在导航算法的入门当中经常会学的一个入门算法就是A*算法，这里整理一下对A*算法的理解。</p><a id="more"></a><p>A*算法本质上就是一个BSF的贪心算法，以下边这个地图为例。  </p><img src="/2019/10/07/A-寻路算法/map.png" title="map"><p>完整的A*算法要考虑到斜着移动等等更复杂的问题，这里先暂时不考虑，只考虑最基本的情况。<br>在整个算法的过程中总共涉及了两个集合三个参数，分别为[Closelist]、[Openlist]、F、G、H。  </p><h1 id="变量说明"><a href="#变量说明" class="headerlink" title="变量说明"></a>变量说明</h1><ul><li><p>Openlist:可达到的格子的集合  </p></li><li><p>Closelist：已到达的格子  </p></li><li><p>F = G + H 对格子价值的评估  </p></li><li><p>G代表从起点到现在格子的距离（成本）  </p></li><li><p>H代表不考虑障碍时当前格子到达终点的距离  </p></li></ul><p>最终的目的就是使F的值最小。  </p><h1 id="算法实现过程"><a href="#算法实现过程" class="headerlink" title="算法实现过程"></a>算法实现过程</h1><p>就以上边的地图为例，总共包括三步：  </p><ul><li>Step1：<br>将可到达的节点放入Openlist链表。  <img src="/2019/10/07/A-寻路算法/Step1.png" title="放入起点">  此时可到达起点，先将起点的坐标作为一个节点放入Openlist链表。  </li><li>Step2：<br>找出Openlist中F值最小的方格，同时将节点移入Closelist，表示已经检查过这个点（能到达该位置）。<br>由于现在只有起始点，所以将起始点放入Closelist。<img src="/2019/10/07/A-寻路算法/Step2.png" title="放入起始点">  </li><li>Step3<br>找到所有能到达的格子，检查是否已经在Openlist中，如果不在就加入Openlist，计算Openlist中每个节点的F值，并把当前的节点作为父节点。  <img src="/2019/10/07/A-寻路算法/Step3.png">  </li></ul><p>之后不停的循环Step2与Step3，直到终点出现在Openlist中则说明寻路结束，否则说明不可到达。  </p><h1 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h1><p>接上边三步。  </p><ul><li><p>Round2<br>现在Openlist中F值最小的节点是Node(2,2),此时将Node(2,2)作为<em>当前方格</em>，并将该节点从Openlist移入Closelist中，表示他已经检擦过了，并加入路径中。  </p><img src="/2019/10/07/A-寻路算法/Round2.png">  </li><li><p>Round3<br>现在将所有能到达的节点全部找出，并计算其F值，新的能到达的节点的父节点为当前方格。  </p><img src="/2019/10/07/A-寻路算法/Round3.png">  <p>然后不断迭代，即可得到最短路径，下边将迭代过程展示出来，不再仔细叙述其中每一步的计算.  </p></li></ul><p>其中金色的为加入到Closelist的节点，浅蓝色的为可到达（Openlist）节点，绿色为当前节点，其父子关系从检索开始到检索结束都不可更改，根据父子关系从目标节点回溯到起始节点。  </p><img src="/2019/10/07/A-寻路算法/1.png">  <img src="/2019/10/07/A-寻路算法/2.png">  <img src="/2019/10/07/A-寻路算法/3.png">  <img src="/2019/10/07/A-寻路算法/4.png">  <img src="/2019/10/07/A-寻路算法/5.png">  <img src="/2019/10/07/A-寻路算法/6.png">  <img src="/2019/10/07/A-寻路算法/7.png">  <img src="/2019/10/07/A-寻路算法/8.png">  <img src="/2019/10/07/A-寻路算法/9.png">  <img src="/2019/10/07/A-寻路算法/10.png">  <img src="/2019/10/07/A-寻路算法/11.png">  <p>至此结束，最终的Closelist应该是一个树状链表，其中到达目标节点的即为所求。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 算法 </category>
          
          <category> SLAM、Navigation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 导航 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu-ssh无法连接时</title>
      <link href="/2019/09/30/ubuntu-ssh%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E6%97%B6/"/>
      <url>/2019/09/30/ubuntu-ssh%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E6%97%B6/</url>
      
        <content type="html"><![CDATA[<p>新装的<code>Ubuntu</code>有可能在ssh连接时连接不上。这个时候应首先确认是否在统一局域网网段下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ifconfig</span><br></pre></td></tr></table></figure><a id="more"></a><p>查看是否用于与主机连接的设备具有同一网段下的IPV4地址。  </p><img src="/2019/09/30/ubuntu-ssh无法连接时/ifconfig.png" title="ifconfig">  <p>如果此时没有IPV4地址，则可以使用  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo ifconfig [DEV NAME] [IPV4 address]</span><br></pre></td></tr></table></figure><p>进行IP设置。  </p><p>如果依旧无法连接，查看是否安装<code>openssh-seaver</code>,安装完再次测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-seaver</span><br></pre></td></tr></table></figure><p>在win上可以使用Xshell全家桶直接连接，在Ubuntu上则可以使用<code>ssh username@IP</code>进行连接（username改为对应的用户名，IP改为对应的ipv4地址）</p>]]></content>
      
      
      <categories>
          
          <category> error&amp;warning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奇淫巧计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS的安装melodic版本</title>
      <link href="/2019/09/29/ROS%E7%9A%84%E5%AE%89%E8%A3%85melodic%E7%89%88%E6%9C%AC/"/>
      <url>/2019/09/29/ROS%E7%9A%84%E5%AE%89%E8%A3%85melodic%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>ROS对系统版本要求极其严格，基本上每一个Ubuntu的LTS（长期支持版）都会有一个ROS的版本与之对应，具体<a href="http://wiki.ros.org/Distributions" target="_blank" rel="noopener">如下</a>  </p><a id="more"></a><img src="/2019/09/29/ROS的安装melodic版本/distro.jpg" title="distro">  <p>打开install的<a href="http://wiki.ros.org/melodic/Installation" target="_blank" rel="noopener">地址</a>,选择你使用的操作系统，win10我试了一次，感觉还是在Linux上方便，感兴趣可以自己试一下。  </p><img src="/2019/09/29/ROS的安装melodic版本/select.jpg" title="select">  <p>进去之后有很完整的安装教程，如果你不想看，而且你的系统是Ubuntu18.04或者是Ubuntu18.4系列的什么系统，你可以直接跟着下边的步骤操作就行。  </p><h1 id="添加ROS的软件源"><a href="#添加ROS的软件源" class="headerlink" title="添加ROS的软件源"></a>添加ROS的软件源</h1><h2 id="国外的软件源"><a href="#国外的软件源" class="headerlink" title="国外的软件源"></a>国外的软件源</h2><p>网速好，能连外网可以直接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &apos;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&apos;</span><br></pre></td></tr></table></figure><h2 id="国内的软件源"><a href="#国内的软件源" class="headerlink" title="国内的软件源"></a>国内的软件源</h2><p>如果你的网速不好，使用国内的镜像源：  </p><ul><li><p>中科大源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &apos;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&apos;</span><br></pre></td></tr></table></figure></li><li><p>清华源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &apos;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&apos;</span><br></pre></td></tr></table></figure></li></ul><h1 id="设置密钥"><a href="#设置密钥" class="headerlink" title="设置密钥"></a>设置密钥</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver &apos;hkp://keyserver.ubuntu.com:80&apos; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure><p>如果使用了代理服务（就是科学上网），那就用下边的命令：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL &apos;http://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0xC1CF6E31E6BADE8868B172B4F42ED6FBAB17C654&apos; | sudo apt-key add -</span><br></pre></td></tr></table></figure><img src="/2019/09/29/ROS的安装melodic版本/添加密钥.jpg" title="添加密钥"><h1 id="更新并安装"><a href="#更新并安装" class="headerlink" title="更新并安装"></a>更新并安装</h1><h2 id="更新软件源"><a href="#更新软件源" class="headerlink" title="更新软件源"></a>更新软件源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>更新软件源。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>之后进行安装，现在嵌入式的板子性能都跟上来了，硬盘也基本都16g起步了，直接装完整版的就可以了,附带各种仿真和可视化插件。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-melodic-desktop-full</span><br></pre></td></tr></table></figure><img src="/2019/09/29/ROS的安装melodic版本/安装.jpg" title="安装"><h2 id="安装其他的ROS组件"><a href="#安装其他的ROS组件" class="headerlink" title="安装其他的ROS组件"></a>安装其他的ROS组件</h2><p>如果需要单独安装ROS的其他包可以尝试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-melodic-PACKAGE</span><br></pre></td></tr></table></figure><p>PACKAGE替换为要安装的包名就可以。  </p><p>要查看都有什么组件是可以用的可以通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt search ros-melodic</span><br></pre></td></tr></table></figure><p>以上操作如果是其他版本的ROS替换其中的melodic为对应的ROS版本即可。  </p><h1 id="初始化和安装依赖"><a href="#初始化和安装依赖" class="headerlink" title="初始化和安装依赖"></a>初始化和安装依赖</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rosdep init</span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>Ubuntu一般是使用<code>~/.bashrc</code>文件进行设置环境变量的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>在终端运行<code>roscore</code>,如果没有报错就说明安装没问题。  </p><p>到这里应该绝大部分功能包都能直接用了，如果有什么功能没有可以单独去搜。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS系列教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu命令行连接WiFi</title>
      <link href="/2019/09/27/Ubuntu%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%9E%E6%8E%A5WiFi/"/>
      <url>/2019/09/27/Ubuntu%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%9E%E6%8E%A5WiFi/</url>
      
        <content type="html"><![CDATA[<p>很多时候没有办法直接用图形界面控制远程的Linux设备，比如ssh连接的时候，这个时候就需要使用cli（命令行）工具进行控制了，经常会使用NetworkManager工具进行网络管理，命令行中使用的命令是<code>nmcli</code>，其功能有一下常用的几项：</p><ul><li>查看网络设备列表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nmcli dev</span><br></pre></td></tr></table></figure></li></ul><p>如果设备状态是<code>unmanaged</code>的，说明网络设备不受NetworkManager管理，你需要清空<code>/etc/network/interfaces</code>下的网络设置，然后重启</p><a id="more"></a><ul><li><p>开启WiFi</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo nmcli r wifi on</span><br></pre></td></tr></table></figure></li><li><p>扫描附近的WiFi</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo nmcli dev wifi</span><br></pre></td></tr></table></figure></li><li><p>连接到指定的WiFi热点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo nmcli dev wifi connect [SSID] password [PASSWORD] ifname [DEVICE NAME]</span><br></pre></td></tr></table></figure></li></ul><p>将SSID、PASSWORD与DEVICE　NAME分别改为实际的WiFi名称、密码与设备名即可连接成功。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python.h:No such file or directory的解决办法</title>
      <link href="/2019/09/21/directory%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2019/09/21/directory%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>出现Python.h:No such file or directory的错误，有两种情况，一种是没有python.h这个文件，一种是python的版本不对，可以进入/usr/includ/文件夹下的pythonx.x文件夹里看一下有没有<code>python.h</code>这个文件<br>如果没有(第一种情况)，可以运行一下  </p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt install python-dev</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> error&amp;warning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YUV颜色编码</title>
      <link href="/2019/09/19/YUV%E9%A2%9C%E8%89%B2%E7%BC%96%E7%A0%81/"/>
      <url>/2019/09/19/YUV%E9%A2%9C%E8%89%B2%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="YUV颜色编码解析"><a href="#YUV颜色编码解析" class="headerlink" title="YUV颜色编码解析"></a>YUV颜色编码解析</h1><p>YUV和RGB、HSV等一样，是颜色空间的一种，常用以流媒体的编码。Y、U、V分别代表了流明、色度、浓度，Y可以表征亮度、UV可以表征色彩，而另一种编码方式<code>Y`CbCr</code>，则为YUV的压缩版本，一般情况下YUV应用于模拟信号，<code>Y`CbCr</code>应用于数字信号，</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 算法 </category>
          
          <category> CV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo嵌入Mermaid流程图</title>
      <link href="/2019/09/12/Hexo%E5%B5%8C%E5%85%A5Mermaid%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
      <url>/2019/09/12/Hexo%E5%B5%8C%E5%85%A5Mermaid%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>写博客过程中遇到了要插流程图、时序图和思维导图的问题，实在是不想去插图片了，能用语法解决的事情为什莫要插图片？于是我打开了Google、bing，于是我又发现了新世界。  </p><h1 id="Mermaid"><a href="#Mermaid" class="headerlink" title="Mermaid"></a>Mermaid</h1><p>首先贴一下官方的<a href="https://www.npmjs.com/package/hexo-filter-mermaid-diagrams" target="_blank" rel="noopener">主页</a>和<a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams" target="_blank" rel="noopener">GitHub</a>  </p><h2 id="打开主题的支持"><a href="#打开主题的支持" class="headerlink" title="打开主题的支持"></a>打开主题的支持</h2><p>我用的主题是<code>next-7.4</code>（吐槽一下7.3的local_search不能用的bug），如果你也是这个版本，那么可以直接去主题的<code>_config.yml</code>文件中去查找<code>mermaid</code> ,将这个模块的enable改为true就可以。  </p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Mermaid tag</span><br><span class="line">mermaid:</span><br><span class="line">  enable: true</span><br><span class="line">  # Available themes: default | dark | forest | neutral</span><br><span class="line">  theme: forest</span><br></pre></td></tr></table></figure><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>然后安装<code>hexo-filter-mermaid-diagrams</code>,官方使用的是<code>yarn</code>安装的插件，其实用<code>npm</code>也可以。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-filter-mermaid-diagrams</span><br><span class="line"></span><br><span class="line">yarn add hexo-filter-mermaid-diagrams </span><br><span class="line">#任选其一</span><br></pre></td></tr></table></figure><h2 id="配置config与swig"><a href="#配置config与swig" class="headerlink" title="配置config与swig"></a>配置config与swig</h2><ol><li><p>编辑博客根目录下的<code>/_config.yml</code>，在最后添加如下内容：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mermaid chart</span><br><span class="line">mermaid: ## mermaid url https://github.com/knsv/mermaid</span><br><span class="line">  enable: true  # default true</span><br><span class="line">  version: &quot;7.1.2&quot; # default v7.1.2</span><br><span class="line">  options:  # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span><br><span class="line">    #startOnload: true  // default true</span><br></pre></td></tr></table></figure></li><li><p>编辑blog/themes/next/layout/_partials/footer.swig，在最后添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.mermaid.enable %&#125;</span><br><span class="line">  &lt;script src=&apos;https://unpkg.com/mermaid@&#123;&#123; theme.mermaid.version &#125;&#125;/dist/mermaid.min.js&apos;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    if (window.mermaid) &#123;</span><br><span class="line">      mermaid.initialize(&#123;&#123; JSON.stringify(theme.mermaid.options) &#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="在vscode上安装插件预览"><a href="#在vscode上安装插件预览" class="headerlink" title="在vscode上安装插件预览"></a>在vscode上安装插件预览</h2><p>在插件中搜索<code>mermaid</code>,直接安装，然后在命令中搜索  </p><img src="/2019/09/12/Hexo嵌入Mermaid流程图/plug.png"><p>就可以进行预览了.<br>ps:用了一会,感觉还是下面这个好用一点,也不用单独命令预览,依旧使用markdown的<code>all in one</code>的插件就可以预览  </p><img src="/2019/09/12/Hexo嵌入Mermaid流程图/good.png"><pre class="mermaid">graph TBA[如果你愿意一层一层剥开我的心]-->B[你会惊讶]B -->  C{里面竟然装满了}C -->  D{火锅}D --> O{饼干}O -->X[还有你]C --> E{烧烤}E --> P{薯片} P -->XC --> F{自助餐}F --> Q{棒棒糖}Q -->XX -->Z[那你就可以在我心里吃火锅烧烤自助餐饼干薯片棒棒糖了]Z -->Y[等你吃完]Y -->U[你就胖得把我的心塞得满满的]U -->V[再也出不去了]</pre><pre class="mermaid">classDiagramClass01 <|-- averylongclass : cool class03 *-- class04 class05 o-- class06 class07 .. class08 class09 --> C2 : Where am i?Class09 --* C3Class09 --|> Class07Class07 : equals()Class07 : Object[] elementDataClass01 : size()Class01 : int chimpClass01 : int gorillaClass08 <--> C2: Cool label</--></|--></pre><img src="/2019/09/12/Hexo嵌入Mermaid流程图/view.png"><h1 id="又记"><a href="#又记" class="headerlink" title="又记"></a>又记</h1><p>又发现一个不一样的流程图工具，这个看起来更好看一点，有空试试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-filter-flowchart</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/icoty23/p/10911231.html" target="_blank" rel="noopener">荒野之萍的博客</a><br><a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams" target="_blank" rel="noopener">插件官方GitHub</a><br><a href="https://www.npmjs.com/package/hexo-filter-mermaid-diagrams" target="_blank" rel="noopener">Mermaid插件官方主页</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> 奇淫巧计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv的编译WIN</title>
      <link href="/2019/09/08/Opencv%E7%9A%84%E7%BC%96%E8%AF%91/"/>
      <url>/2019/09/08/Opencv%E7%9A%84%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1 id="CV源码"><a href="#CV源码" class="headerlink" title="CV源码"></a>CV源码</h1><p>源码肯定是要先有的，<a href="https://github.com/opencv/opencv" target="_blank" rel="noopener">opencv</a>、<a href="https://github.com/opencv/opencv_contrib" target="_blank" rel="noopener">opencv_contrib</a>,推荐用<code>git</code>下载，不然版本是没办法在下载之后进行切换的。  </p><p>很明显再Linux上没有任何难度，就把Linux往后放放，先说win10</p><h1 id="在win10上借助vs进行编译"><a href="#在win10上借助vs进行编译" class="headerlink" title="在win10上借助vs进行编译"></a>在win10上借助vs进行编译</h1><h2 id="安装cmake"><a href="#安装cmake" class="headerlink" title="安装cmake"></a>安装cmake</h2><p>win10的话直接去<a href="https://cmake.org/download/" target="_blank" rel="noopener">官网</a>上下载msi的安装包双击安装就行,如下，选64位的安装  </p><a id="more"></a>  <p>下一步就行，可以选择把路径加入系统环境变量里。  </p><h2 id="安装Visual-Studio-IDE"><a href="#安装Visual-Studio-IDE" class="headerlink" title="安装Visual Studio IDE"></a>安装Visual Studio IDE</h2><p><a href="https://visualstudio.microsoft.com/zh-hans/vs/community/?rr=https%3A%2F%2Fcn.bing.com%2F" target="_blank" rel="noopener">官网</a>直接下载，在线安装社区版（Community），免费的！勾个扩展，勾个想要的组件点安装就完事了，想要python就勾一个，缺东西安装完成后也可以再单独添加。  </p><img src="/2019/09/08/Opencv的编译/vs_install.PNG" title="VS_INSTALL">  <p>记得选中<code>Desktop development with C++</code>,这个应该会包含<code>Visual C++ tools for CMake</code>  </p><img src="/2019/09/08/Opencv的编译/解决err1.PNG" title="添加c++工具">  <p>如果不选会出现：  </p><img src="/2019/09/08/Opencv的编译/err1.PNG" title="err1">  <p><strong>同时一定要保证源码的完整性，刚开始报了各种错误都是因为源码不完整导致的。</strong></p><h2 id="打开cmake进行配置"><a href="#打开cmake进行配置" class="headerlink" title="打开cmake进行配置"></a>打开cmake进行配置</h2><p>打开cmake图形界面：</p><ol><li>输入源码路径</li><li>选择输出路径，可以自己新建一个</li><li>点击config  <img src="/2019/09/08/Opencv的编译/cmake.PNG" title="cmake界面">  </li></ol><p>完成后添加contrib库：  </p><img src="/2019/09/08/Opencv的编译/contrib.PNG" title="附加库">  <p>之后搜索<code>build_opencv_world</code>,勾上，这里一定要勾上！！！</p><img src="/2019/09/08/Opencv的编译/vuild_opencv_world.png" title="world">  <p>之后再此点击config，出现<code>configuring done</code>就可以点<code>generate</code>  </p><img src="/2019/09/08/Opencv的编译/config_done.PNG">  <p>全部通过后会有：  </p><img src="/2019/09/08/Opencv的编译/sln.PNG" class="generate.PNG } 出现IPPICV或者ffmpeg下载失败等问题，建议尝试科学上网。 ## 打开vs进行编译 进入之前新建的build目录，如果刚刚的步骤一切顺利，这里会有一个vs的解决方案文件`.sln` {%asset_img">  <p>打开他，找到all_build  </p><img src="/2019/09/08/Opencv的编译/build.PNG"><p>右键生成，经过漫长的等待，，，直到：<br>弹出了个错误！！  </p><img src="/2019/09/08/Opencv的编译/err2_python.PNG">  <h3 id="解决LNK1104-打不开python3-d-lib"><a href="#解决LNK1104-打不开python3-d-lib" class="headerlink" title="解决LNK1104,打不开python3_d.lib"></a>解决LNK1104,打不开python3_d.lib</h3><p>重新打开当时安装python的程序，点击修改，然后勾上<code>debug</code>选项，就像这样：  </p><img src="/2019/09/08/Opencv的编译/err2.PNG">  <p>然后安装，安装完成后给opencv_python3添加<code>.lib</code>路径  </p><img src="/2019/09/08/Opencv的编译/err2_add_path.PNG">  <p>打开属性，依次添加库目录与附加依赖项:  </p><ol><li><p>将<code>python37_d.lib</code>所在文件夹的路径添加到库目录（用以指定搜索<code>.lib</code>的路径）里面</p><img src="/2019/09/08/Opencv的编译/python_lib.png">  </li><li><p>添加附加依赖项<code>python37_d.lib</code>  </p><img src="/2019/09/08/Opencv的编译/err2_fujia.png">  </li></ol><p><strong>应该是如果添加了库目录，这里就可以只写文件名，反之则可以写完整路径。</strong></p><p>附加项中添加的路径就是刚找到的<code>python37.lib</code>的路径。</p><img src="/2019/09/08/Opencv的编译/err2_libs.png">  <p>然后重新生成opencv_python3,成功。</p><img src="/2019/09/08/Opencv的编译/err2_well.png">  <p><a href="https://blog.csdn.net/weixin_43788499/article/details/84933210" target="_blank" rel="noopener">参考</a></p><p>之后生成<code>INSTALL</code>,成功会显示：  </p><img src="/2019/09/08/Opencv的编译/install.png">  <p>然后就可以在编译好的文件就可以在install文件夹中找到了。</p><img src="/2019/09/08/Opencv的编译/over.png">  <h1 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h1><p>新建一个项目，随便起一个名字。<br>打开下边的选项。</p><img src="/2019/09/08/Opencv的编译/shuxingguanli.png">  <img src="/2019/09/08/Opencv的编译/dianjishuxing.png">  <p>打开属性，修改下边的两项,以及附加依赖项<code>opencv_world412.lib</code>(我的cv版本是4.12的所以是412，同时这里也是为什莫上边<code>cmake config</code>一定要勾选<code>build_opencv_world</code>的原因)  </p><img src="/2019/09/08/Opencv的编译/vs_config.png"><ol><li>包含目录  <img src="/2019/09/08/Opencv的编译/baohan.png" title="包含目录"></li><li>库目录<img src="/2019/09/08/Opencv的编译/ku.png" title="库目录"></li><li>附加依赖项  <img src="/2019/09/08/Opencv的编译/fujiayilai.png" title="附加依赖"><strong>这里应该需要添加所有的<code>.lib</code>文件，复制下边的bat脚本在lib目录下运行就可以得到所有的文件名，记得将<code>.cmake</code>文件删掉再复制进附加依赖项</strong>  </li></ol><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">DIR</span> "./" /B &gt;A.TXT</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure><p>之后就可以跑一个例程测试一下了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/videoio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Mat frame;</span><br><span class="line"><span class="comment">//--- INITIALIZE VIDEOCAPTURE</span></span><br><span class="line">VideoCapture cap;</span><br><span class="line"><span class="comment">// open the default camera using default API</span></span><br><span class="line"><span class="comment">// cap.open(0);</span></span><br><span class="line"><span class="comment">// OR advance usage: select any API backend</span></span><br><span class="line"><span class="keyword">int</span> deviceID = <span class="number">0</span>;             <span class="comment">// 0 = open default camera</span></span><br><span class="line"><span class="keyword">int</span> apiID = cv::CAP_ANY;      <span class="comment">// 0 = autodetect default API</span></span><br><span class="line"><span class="comment">// open selected camera using selected API</span></span><br><span class="line">cap.open(deviceID + apiID);</span><br><span class="line"><span class="comment">// check if we succeeded</span></span><br><span class="line"><span class="keyword">if</span> (!cap.isOpened()) &#123;</span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; <span class="string">"ERROR! Unable to open camera\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--- GRAB AND WRITE LOOP</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Start grabbing"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"Press any key to terminate"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// wait for a new frame from camera and store it into 'frame'</span></span><br><span class="line">cap.read(frame);</span><br><span class="line"><span class="comment">// check if we succeeded</span></span><br><span class="line"><span class="keyword">if</span> (frame.empty()) &#123;</span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; <span class="string">"ERROR! blank frame grabbed\n"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// show live and wait for a key with timeout long enough to show images</span></span><br><span class="line">imshow(<span class="string">"Live"</span>, frame);</span><br><span class="line"><span class="keyword">if</span> (waitKey(<span class="number">5</span>) &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// the camera will be deinitialized automatically in VideoCapture destructor</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常是可以打开USB摄像头并显示的。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 算法 </category>
          
          <category> CV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS的工程目录</title>
      <link href="/2019/09/08/ROS%E7%9A%84%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95/"/>
      <url>/2019/09/08/ROS%E7%9A%84%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">优秀的人，不是不合群，而是他们合群的人里面没有你</blockquote><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p>按照官方的<a href="http://wiki.ros.org/cn/ROS/Tutorials" target="_blank" rel="noopener">Wiki</a>来看，ROS整体是由文件系统级、计算图级、社区级三个层级，这里先来看一下他的工程目录结构,我的叙述难免会有失偏颇，可以参考官方的<a href="http://wiki.ros.org/cn/ROS/Tutorials" target="_blank" rel="noopener">Wiki</a>进行理解。</p><a id="more"></a><h2 id="文件系统级"><a href="#文件系统级" class="headerlink" title="文件系统级"></a>文件系统级</h2><img src="/2019/09/08/ROS的工程目录/ROS文件系统架构.jpg" title="文件架构">  <p>其不同功能的组件是放在不同的目录下的，目录是按照功能进行分类的。  </p><ol><li><p>工作空间：<br>工作空间是一个包含功能包、编译包、可执行程序的文件夹，类似于vsIDE里新建的一个工程目录，可以在一个工程中做多个功能包，也可以做多个工作空间把功能分开，按自己的习惯来就好，一般第一个工作空间都会新建成catkin_ws，初始化完成后目录下会有三个文件夹：src、build、devel。  </p><ul><li><strong>src源工作空间</strong>：这个文件夹用于存放功能包和一个用于配置这些功能包的cmake文件CMakeLists.txt。由于ROS中的源码采用catkin工具进行编译，虽然每一个版本的catkin工具会有一些变化，但总体都是基于cmake的，所以在src源文件空间和各个功能包中都会有一个CMakeLists.txt文件，这个文件就是起编译配置的作用。</li><li><strong>build编译文件目录</strong>：用于存放CMake和catkin编译功能包时产生的缓存、配置、中间文件等。</li><li><strong>devel执行文件目录</strong>：编译好的可执行程序，可以不用安装直接运行的二进制文件，可以通过直接导出这些文件与其他人共享开发的成果。</li></ul></li><li><p>packages<br>一个功能包具有用于创建ROS程序的最小结构和最少内容，它可以包含ROS运行的进程（节点）、配置文件等。</p><ul><li><p><strong>CMakeLists.txt功能包配置文件</strong>：用于编译时的配置文件。</p></li><li><p><strong>package.xml功能包清单文件</strong>：用xml的标签格式标记这个功能包的各类相关信息，比如包的名称、<strong><em>依赖</em></strong>关系等。主要作用是为了更容易的<strong><em>安装依赖</em></strong>和分发功能包。<code>rosdep install</code>就是根据这里的信息进行安装的！！！</p></li><li><p><strong>src功能包源文件</strong>：具体的任务实现，各进程各节点程序的源文件存放目录。主要需要关注和开发的目录。</p></li><li><p>msg非标准消息定义：如果ROS提供的标准消息定义的数据类型不能满足需求可以在这里另外定义，非必须目录。</p></li><li><p>srv非标准服务定义：如果ROS提供的标准服务定义的数据类型不能满足需求可以在这里另外定义，非必须目录。</p></li><li><p>scripts可执行脚本文件存放目录：各种可执行脚本存放的地方，可以支持bash、python、js等等，但用不着就不用整这个目录了。</p></li><li><p>launch文件目录：多个节点（线程）同时启动时可以通过在<code>.launch</code>文件中列出来可执行程序及参数，然后只启动一个<code>*.launch</code>文件就可以启动整个工程，同样的，需要这个功能就加，不需要就不用添加这个目录。  </p></li><li><p>ROS提供了很多用于增删改查功能包的快捷工具，有一些常用的：<br>rospack find [package name]：用于获取信息或在系统中查找工作空间。  </p><p>   catkin_create_pkg：用于在工作空间的src源空间下创建一个新的功能包。  </p><p>   catkin_make：用于编译工作空间中的功能包。  </p><p>   rosdep install [package]：用于安装packages的所需的系统依赖项，详情可看<a href="http://wiki.ros.org/cn/ROS/Tutorials/rosdep" target="_blank" rel="noopener">Wiki</a>。  </p><p>   rqt_dep：用于查看功能包的依赖关系图。</p><p>   等等还有很多，入门常用的都在<a href="http://wiki.ros.org/cn/ROS/Tutorials" target="_blank" rel="noopener">这里</a>。  </p><h2 id="计算图级"><a href="#计算图级" class="headerlink" title="计算图级"></a>计算图级</h2></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS系列教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS是什么？</title>
      <link href="/2019/09/06/ROS%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2019/09/06/ROS%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="一切开始的地方"><a href="#一切开始的地方" class="headerlink" title="一切开始的地方"></a>一切开始的地方</h1><p>网上有很多乱糟糟的教程，很大很宽泛，讲很多，但是却一行代码没有写、一块PCB没有做，全是如何运行官方的demo，大家都在千篇一律的抄些形式上的东西，我觉得这不是知识应该存在的方式。<br>在这里回顾一下我的学习历程，把我自己学到的东西分享出来，希望看到的能指出我有不对的地方，同时也希望大家能一起进步。  </p><a id="more"></a><h1 id="什么是ROS"><a href="#什么是ROS" class="headerlink" title="什么是ROS"></a>什么是ROS</h1><p>Robot Operating System,前身是斯坦福的人工智能实验室的项目，是一款适用于机器人的开源操作系统，他有操作系统所应有的一切，但准确来说又不是一个操作系统，他是在操作系统之上的一个次级系统，只是运行在Linux上的一个软件（现在已经支持win10），其底层的编译、寻址等任务依旧由真正的操作系统来承担，但是ros也提供了包括像包管理、硬件抽象、底层硬件控制、消息传递的机制等等，甚至包括用以跨平台的编译工具，其富有特征的松耦合通信机制（模拟的TCP/IP通信机制）使得其模块非常容易进行扩展，满足了机器人多组件、算法的快速部署与跨平台，提高了系统的稳定性。</p><h2 id="ROS的组成"><a href="#ROS的组成" class="headerlink" title="ROS的组成"></a>ROS的组成</h2><h3 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h3><p>将所有的部件做成节点<code>node</code>，这些节点可以分布在多个机器上，拥有很高的松耦合特性</p><h3 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h3><p><code>topic</code>与<code>serve</code>的通信机制，利用<code>master</code>节点进行管理，同时由<code>master</code>提供全局的参数配置</p><h3 id="常用的工具集"><a href="#常用的工具集" class="headerlink" title="常用的工具集"></a>常用的工具集</h3><ul><li>命令工具rostopic、rosservice、rosnode、rosparam、rosmsg、rossrv、roswtf</li><li>可视化工具是rqt、rviz；存储与回放数据的工具rosbag</li><li>第三方工具：三维仿真环境Gazebo、计算机视觉库OpenCV、点云库PCL、机械臂控制库MoveIt、工业应用库Industrial、机器人编程工具箱MRPT、实时控制库Orocos。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS系列教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查询系统版本和内核版本</title>
      <link href="/2019/09/06/%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E5%92%8C%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC/"/>
      <url>/2019/09/06/%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E5%92%8C%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>查询Linux的版本号与内核版本</p><a id="more"></a><h1 id="查询版本信息"><a href="#查询版本信息" class="headerlink" title="查询版本信息"></a>查询版本信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/lsb-release</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/version</span><br></pre></td></tr></table></figure><h1 id="显示Linux内核版本系统位数"><a href="#显示Linux内核版本系统位数" class="headerlink" title="显示Linux内核版本系统位数"></a>显示Linux内核版本系统位数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br><span class="line">uname -r</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure><p>其中codename是Ubuntu代号</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git添加tag</title>
      <link href="/2019/09/05/git%E6%B7%BB%E5%8A%A0tag/"/>
      <url>/2019/09/05/git%E6%B7%BB%E5%8A%A0tag/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在发布软件时会加一个tag标注版本号，比如opencv可以通过tag转成对应的版本，tag会记录对应版本的commit号，所以在回溯版本时会非常的方便。</p><a id="more"></a><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="列出所有tag"><a href="#列出所有tag" class="headerlink" title="列出所有tag"></a>列出所有tag</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><p>加上<code>-l</code>可以进行过滤，效果类似<code>grep</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -l &quot;4.0*&quot;</span><br></pre></td></tr></table></figure><h2 id="新建命令"><a href="#新建命令" class="headerlink" title="新建命令"></a>新建命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag 1.0</span><br></pre></td></tr></table></figure><p>可以新建一个叫<code>1.0</code>的tag，加上参数<code>-a</code>可以创建带备注的tag，备注信息由<code>-m</code>指定，未指定<code>-m</code>则系统会提示输入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a tagname -m &quot;备注信息&quot;</span><br></pre></td></tr></table></figure><h2 id="查看tag详细信息"><a href="#查看tag详细信息" class="headerlink" title="查看tag详细信息"></a>查看tag详细信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show tagname</span><br></pre></td></tr></table></figure><p>查看对应的tag详细信息，此时会打出commit号，方便回溯。</p><h2 id="同步tag到远程服务器"><a href="#同步tag到远程服务器" class="headerlink" title="同步tag到远程服务器"></a>同步tag到远程服务器</h2><p><code>git push origin [tagname]</code>推送单个分支  </p><img src="/2019/09/05/git添加tag/推送tag.png">  <p><code>git push origin --tags</code>推送所有分支</p><h2 id="切换到指定tag"><a href="#切换到指定tag" class="headerlink" title="切换到指定tag"></a>切换到指定tag</h2><p>可以直接切换，但是切换之后处于游离状态，不属于任何分支（branch），故此时可以直接基于此tag新建一个分支。</p><h2 id="删除tag"><a href="#删除tag" class="headerlink" title="删除tag"></a>删除tag</h2><ul><li><p>本地删除  </p><pre><code>git tag -d [tagname]</code></pre></li><li><p>远端删除</p><pre><code>git push origin :refs/tags/&lt;tagname&gt;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让vscode成为c/c++编译器</title>
      <link href="/2019/08/31/%E8%AE%A9vscode%E6%88%90%E4%B8%BAc-c-%E7%BC%96%E8%AF%91%E5%99%A8/"/>
      <url>/2019/08/31/%E8%AE%A9vscode%E6%88%90%E4%B8%BAc-c-%E7%BC%96%E8%AF%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>安装了vscode之后，写代码和丝滑流畅，脱离臃肿的<code>Visual Studio IDE</code>，优雅的进行断点调试，直接进行编译与运行，下边记录一下配置的过程。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>vscode本身是不带编译器的，无论通过什么方式进行编译和运行都是需要外部的编译器的，只需要提前安装好对应的编译器，并设置好环境变量，vscode就可以调用到。  </p><p>vscode可以通过终端<em>使用命令行</em>进行编译，也可以借助<code>code runner</code>进行简化编译。</p><h1 id="安装编译器"><a href="#安装编译器" class="headerlink" title="安装编译器"></a>安装编译器</h1><p>如果使用<code>code runner</code>进行编译运行的话是需要安装g++/gcc的，如果是Linux直接命令行安装就行，win10的话需要提前安装并设置环境变量，通常选择安装<a href="https://sourceforge.net/projects/mingw/files/latest/download?source=files" target="_blank" rel="noopener">MinGW</a>或者<a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/" target="_blank" rel="noopener">MinGW-w64</a>，推荐使用MinGW-w64，这两个其实差不多，但是听说MinGW-w64是MinGW的升级版，更强更骚，总之装MinGW-w64就OK。  </p><p>安装MinGW-w64的过程没什莫要说的，在安装过程中注意将<code>arch</code>改为x86_64，如下图：  </p><img src="/2019/08/31/让vscode成为c-c-编译器/install_mingw.PNG" title="修改"> <p>win10的话之后要添加一下环境变量，将安装路径下的<code>bin</code>文件夹与<code>includ</code>文件夹分别加入系统环境变量的<code>Path</code>与<code>C_INCLUDE_PATH</code> ( 这个需要自己新建，也可以为c++设立一个c++的头文件搜索路径<code>CPLUS_INCLUDE_PATH</code> )  </p><p>安装目录：  </p><img src="/2019/08/31/让vscode成为c-c-编译器/path.PNG" title="安装目录">  <p>添加路径：  </p><img src="/2019/08/31/让vscode成为c-c-编译器/add_path.PNG" title="添加路径"><p>安装完成后，测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -v</span><br><span class="line">gcc -v</span><br></pre></td></tr></table></figure><p>如下表示安装正常</p><img src="/2019/08/31/让vscode成为c-c-编译器/successfu_linstall.PNG" title="安装完成"><h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><p>去左侧的插件商店中所搜一下 <code>C/C++</code>与<code>Code runner</code> 这两个插件，装上，这时候在右上角就能出现一个能直接运行的三角：  </p><img src="/2019/08/31/让vscode成为c-c-编译器/run_code.PNG" title="运行按钮">  <p>但是这时候运行不是在vscode集成的控制台里的，我们需要修改一下设置：文件&gt;首选项&gt;设置&gt;用户设置&gt;拓展&gt;Run Code Configuration（直接搜Run Code Configuration往下翻也能找到）  </p><img src="/2019/08/31/让vscode成为c-c-编译器/run_in_terminal.PNG" title="设置">  <p>下边测试一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"hello world"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，runcode只是帮我们运行了<code>g++ xxx.cpp -o xxx.exe</code>，而不会加别的东西，也就是说，如果我们调用了opencv的库，这时候编译会出错的，因为他不会给我们加上<code>-lopencv</code>,这个时候我们就依然需要在命令行里手写g++了。</p><p>ps：<code>bits/stdc++.h</code>是一个万能c++库，他包含了基本所有常用的c++库，但是也会造成编译慢的问题，能不用还是不要用。</p><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>要实现断点调试需要先在工作区目录下新建一个<code>.vscode</code>文件夹（win10下如果不能新建<code>.</code>开头的文件夹，重命名成<code>.vscode.</code>就可以解决问题），添加两个文件， <code>launch.json</code> 和 <code>tasks.json</code><br>将一下代码分别加入两个文件。<br>launch.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"C/C++"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [],</span><br><span class="line">            <span class="attr">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span>,</span><br><span class="line">            <span class="attr">"environment"</span>: [],</span><br><span class="line">            <span class="attr">"externalConsole"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">            <span class="attr">"miDebuggerPath"</span>: <span class="string">"D:/Program Files/mingw-w64/x86_64-8.1.0-posix-seh-rt_v6-rev0/mingw64/bin/gdb.exe"</span>,</span><br><span class="line">            <span class="attr">"preLaunchTask"</span>: <span class="string">"g++"</span>,</span><br><span class="line">            <span class="attr">"setupCommands"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"description"</span>: <span class="string">"Enable pretty-printing for gdb"</span>,</span><br><span class="line">                    <span class="attr">"text"</span>: <span class="string">"-enable-pretty-printing"</span>,</span><br><span class="line">                    <span class="attr">"ignoreFailures"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>miDebuggerPath</code> 参数是用以搜索mingw安装的调试器(<code>gdb.exe</code>)的 ，所以这个路径要设置正确<br>ps : <code>externalConsole</code>参数为<code>fales</code> 时才是在vscode集成的命令行中进行调试。 </p><p>tasks.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="attr">"command"</span>: <span class="string">"g++"</span>,</span><br><span class="line">    <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"-g"</span>,</span><br><span class="line">        <span class="string">"$&#123;file&#125;"</span>,</span><br><span class="line">        <span class="string">"-o"</span>,</span><br><span class="line">        <span class="string">"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"problemMatcher"</span>: &#123;</span><br><span class="line">        <span class="attr">"owner"</span>: <span class="string">"cpp"</span>,</span><br><span class="line">        <span class="attr">"fileLocation"</span>: [</span><br><span class="line">            <span class="string">"relative"</span>,</span><br><span class="line">            <span class="string">"$&#123;workspaceRoot&#125;"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"pattern"</span>: &#123;</span><br><span class="line">            <span class="attr">"regexp"</span>: <span class="string">"^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$"</span>,</span><br><span class="line">            <span class="attr">"file"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"line"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"column"</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">"severity"</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">"message"</span>: <span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"group"</span>: &#123;</span><br><span class="line">        <span class="attr">"kind"</span>: <span class="string">"build"</span>,</span><br><span class="line">        <span class="attr">"isDefault"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时可以按 <code>ctrl+shift+b</code> 直接调用配置好的g++ task 编译程序而不运行程序，但是要注意如果要单步运行就要有断点存在，不然在左侧的<code>debug</code>窗口中没有变量显示，也不能暂停，至少我在实际使用中是这样的情况。  </p><img src="/2019/08/31/让vscode成为c-c-编译器/debug.PNG" title="debug">]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> 奇淫巧计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux调用动态链接库（.so）的方法</title>
      <link href="/2019/08/24/linux%E8%B0%83%E7%94%A8%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88-so%EF%BC%89%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2019/08/24/linux%E8%B0%83%E7%94%A8%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88-so%EF%BC%89%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>动态链接库在编译的时候不会编译进去，所以需要制定系统对动态链接库的搜索路径，<code>-L</code>(<code>l</code>与<code>L</code>区别暂时还不清楚，应该<code>l</code>同理)添加的搜索路径仅用于编译，所以如果搜索不到动态链接库则会在运行时报错。</p><a id="more"></a><ol><li>在<code>/etc/ld.so.conf.d/</code>下创建<code>xxx.conf</code>(xxx为库名例如opencv.conf)，在文本中加入<code>.so</code>所在路径，如：<code>/usr/lib</code>、<code>/usr/xxx</code>等等，使用<code>sudo ldconfig</code>命令使之生效。</li><li>将<code>.so</code>所在路径添加为<code>LD_LIBRARY_PATH</code>环境变量。</li><li>在编译命令中使用<code>-Wl,-rpath=./</code>参数，并将相应<code>.so</code>拷贝到执行目录（未使用过）；  </li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有1个软件包没有被完全安装或卸载</title>
      <link href="/2019/08/24/%E6%9C%891%E4%B8%AA%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%AE%8C%E5%85%A8%E5%AE%89%E8%A3%85%E6%88%96%E5%8D%B8%E8%BD%BD/"/>
      <url>/2019/08/24/%E6%9C%891%E4%B8%AA%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%AE%8C%E5%85%A8%E5%AE%89%E8%A3%85%E6%88%96%E5%8D%B8%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>安装百度网盘时卡住了，重装完成后发现所有的apt安装都会弹出这样一个信息  </p><img src="/2019/08/24/有1个软件包没有被完全安装或卸载/2019-08-24_14-17.png" title="报错信息">  <a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">正在设置 baidunetdisk (2.0.2) ...</span><br><span class="line">/var/lib/dpkg/info/baidunetdisk.postinst: 1: /var/lib/dpkg/info/baidunetdisk.postinst: update-desktop-database: not found</span><br><span class="line">dpkg: 处理软件包 baidunetdisk (--configure)时出错：</span><br><span class="line"> 已安装 baidunetdisk 软件包 post-installation 脚本 子进程返回错误状态 127</span><br><span class="line">在处理时有错误发生：</span><br><span class="line"> baidunetdisk</span><br><span class="line">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br></pre></td></tr></table></figure><p>解决办法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /var/lib/dpkg</span><br><span class="line">$ sudo mv info info.baksudo</span><br><span class="line">$ mkdir info</span><br></pre></td></tr></table></figure><p>成功解决</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好用的工具</title>
      <link href="/2019/08/23/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"/>
      <url>/2019/08/23/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>发现了几个好用的工具，之后遇到新的再更新</p><a id="more"></a><h1 id="flameshot截图工具"><a href="#flameshot截图工具" class="headerlink" title="flameshot截图工具"></a>flameshot截图工具</h1><p>界面非常干净，我是用软件中心安装的，apt应该也可以的。<br>直接点击就可以调用：  </p><img src="/2019/08/23/常用工具汇总/2019-08-23_16-58.png">   <p>可以置顶悬浮也可以进行绘制之后保存。</p><h1 id="kfind搜索工具"><a href="#kfind搜索工具" class="headerlink" title="kfind搜索工具"></a>kfind搜索工具</h1><p>稳定不闪退，搜索速度也可以</p><h1 id="Everything"><a href="#Everything" class="headerlink" title="Everything"></a>Everything</h1><p>win下的搜索工具，全局搜索速度非常快。</p><h1 id="Snipaste"><a href="#Snipaste" class="headerlink" title="Snipaste"></a>Snipaste</h1><p>win下的截图工具，小巧方便，可以临时截图悬浮，同时已经支持MAC OS，Linux也会马上支持。Snipaste<br><a href="https://zh.snipaste.com/" target="_blank" rel="noopener">https://zh.snipaste.com/</a></p><h1 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h1><p>查看文件目录</p><h1 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h1><p>界面友好的top，方便查看内存和cpu占用，包括进程管理。</p><img src="/2019/08/23/常用工具汇总/Snipaste_2020-02-08_15-04-57.png"><h1 id="某兔瑞"><a href="#某兔瑞" class="headerlink" title="某兔瑞"></a>某兔瑞</h1><p>**都懂</p><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><p>GitHub:<br><a href="https://github.com/**/**-core" target="_blank" rel="noopener">https://github.com/**/**-core</a><br>客户端和服务端共用一套配置文件：config.json  </p><h2 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a>在线安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">bash &lt;(curl -L -s https://install.direct/go.sh)</span><br></pre></td></tr></table></figure><h2 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h2><p>先到github上下载**-linux-64.zip压缩包，并放在ubuntu的本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://install.direct/go.sh</span><br><span class="line">sudo bash go.sh --local ./**-linux-64.zip</span><br></pre></td></tr></table></figure><p>使用go.sh安装完成后会在系统中自动安装以下组件：</p><p>/usr/bin/ ** / ** ：** 程序；<br>/usr/bin/ ** /v2ctl：** 工具；<br>/etc/ ** /config.json：配置文件；<br>/usr/bin/ ** /geoip.dat：IP 数据文件<br>/usr/bin/ ** /geosite.dat：域名数据文件  </p><p>此脚本会配置自动运行脚本。自动运行脚本会在系统重启之后，自动运行 **。目前自动运行脚本只支持带有 Systemd 的系统，以及 Debian / Ubuntu 全系列。  </p><p>运行脚本位于系统的以下位置：  </p><p>/etc/systemd/system/  ** .service: Systemd<br>/etc/init.d/ **  : SysV  </p><p>脚本运行完成后，你需要：  </p><p>编辑 /etc/ ** /config.json 文件来配置你需要的代理方式；<br>运行 <code>service ** start</code> 来启动 ** 进程；<br>之后可以使用 <code>service ** start | stop | status | reload | restart | force-reload</code>控制 ** 的运行。  </p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>注意port。可以从win上导出。<br>config.config:  </p><img src="/2019/08/23/常用工具汇总/Snipaste_2020-02-08_17-26-10.png">  <h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl  start  **   #启动 **</span><br><span class="line">sudo systemctl  status **   #查看 ** 状态 </span><br><span class="line">sudo systemctl  stop   **   #停止 **</span><br></pre></td></tr></table></figure><h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><p>SwitchyOmega插件可以用于chrome。<br>系统可以使用p<code>roxychains4</code><br>防止失效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/rofl0r/proxychains-ng.git</span><br><span class="line">cd proxychains-ng</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">cp ./src/proxychains.conf /etc/proxychains.conf</span><br><span class="line">cd .. &amp;&amp; rm -rf proxychains-ng</span><br><span class="line"> </span><br><span class="line">vim /etc/proxychains.conf</span><br><span class="line"> </span><br><span class="line">将socks4 127.0.0.1 9095改为</span><br><span class="line">socks5 127.0.0.1 1080 ## 留意config</span><br><span class="line"> </span><br><span class="line">ps: 默认的socks4 127.0.0.1 9095是tor代理，而socks5 127.0.0.1 1080是shadowsocks的代理。</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 git clone git@github.com:qm-k/Algorithm_Getting_Started.git</span><br><span class="line">proxychains4  rosdep update</span><br></pre></td></tr></table></figure><p>—————————–2020/2/8———————————-</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git添加公钥</title>
      <link href="/2019/08/23/git%E6%B7%BB%E5%8A%A0%E5%85%AC%E9%92%A5/"/>
      <url>/2019/08/23/git%E6%B7%BB%E5%8A%A0%E5%85%AC%E9%92%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>给github添加公钥，以防止每次push都需要输入账户密码。</p><a id="more"></a><h1 id="查看是否已有公钥"><a href="#查看是否已有公钥" class="headerlink" title="查看是否已有公钥"></a>查看是否已有公钥</h1><p>进入<code>~/.ssh</code>目录如果有的话可以用<code>ll</code>或者<code>ls -la</code>（l为显示权限详细信息，a是显示包括隐藏文件，<code>ll</code>同<code>-la</code>效果）查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -ls ~/.ssh/</span><br><span class="line">total 4</span><br><span class="line">4 -rw-r--r-- 1 melrose_legend melrose_legend 884 8月  23 15:46 known_hosts</span><br></pre></td></tr></table></figure><p>PS:在win10的powershell中<code>.ssh</code>路径是一致的，<code>~/</code>路径在win10上对应为<code>C:\Users\username\</code></p><h1 id="生成新的SSH-KEY"><a href="#生成新的SSH-KEY" class="headerlink" title="生成新的SSH KEY"></a>生成新的SSH KEY</h1><p>输入<code>ssh-keygen -t rsa -C “email@email.com”</code>其中<code>“email@email.com”</code>为github账号,之后一路回车，效果如下： </p><img src="/2019/08/23/git添加公钥/2019-08-23_16-31.png">   <h1 id="登录Github，点击setting添加公钥"><a href="#登录Github，点击setting添加公钥" class="headerlink" title="登录Github，点击setting添加公钥"></a>登录Github，点击setting添加公钥</h1><p>添加公钥  </p>  <p>输入<code>.pub</code>的内容，同时为此公钥设置一个名字，方便记忆（防止那一天忘了这是哪一台机器的公钥了）  </p>  <h1 id="测试是否成功"><a href="#测试是否成功" class="headerlink" title="测试是否成功"></a>测试是否成功</h1><pre><code>ssh -T git@github.com</code></pre><p>如下图即为配置成功：  </p> ]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh-keygen的使用方法</title>
      <link href="/2019/08/23/ssh-keygen%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2019/08/23/ssh-keygen%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了让两个Linux机器之间使用ssh而不使用密码，采用数字签名RSA和DSA（两种加密方式）来完成</p><h1 id="具体流程，A登录B"><a href="#具体流程，A登录B" class="headerlink" title="具体流程，A登录B"></a>具体流程，A登录B</h1><ol><li>登录A机</li><li>ssh-keygen -t [rsa|dsa],将会生成公钥和私钥，id_rsa和id_rsa.pub或id_dsa和id_dsa.pub（分别基于两种加密方式）</li><li>将.pub文件复制到B机器的.ssh目录，并<code>cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code></li><li>从A机登录B机不再需要密码，可以直接运行<code>ssh 192.-.-.-</code>,此时也可以修改<code>/etc/host</code>文件，连id也不用输入，只输入用户名</li></ol><a id="more"></a><h1 id="设置文件权限"><a href="#设置文件权限" class="headerlink" title="设置文件权限"></a>设置文件权限</h1><p>设置<code>authorized_keys</code>文件权限为600</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 600 authorized_keys</span><br></pre></td></tr></table></figure><p>设置<code>.ssh</code>目录权限为700</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 700 -r .ssh</span><br></pre></td></tr></table></figure><p>要保证<code>authorized_keys、.ssh</code>都只有用户自己有写权限才可以，否则数字签名不支持</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell判断参数</title>
      <link href="/2019/08/23/shell%E5%88%A4%E6%96%AD%E5%8F%82%E6%95%B0/"/>
      <url>/2019/08/23/shell%E5%88%A4%E6%96%AD%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="if-ne-0-中的-ne"><a href="#if-ne-0-中的-ne" class="headerlink" title="if[$? -ne 0]中的-ne"></a>if[$? -ne 0]中的-ne</h1><p>有几个常用的用于判断的参数：</p><a id="more"></a><ul><li>-ne 不等于</li><li>-eq 等于</li><li>-gt 大于</li><li>-ge 大于等于</li><li>-lt 小于</li><li>-le 小于等于</li><li>&lt;、&gt;、≥、≤  </li></ul><p>以上使用字符的参数均需使用<code>[]</code>框起来，而最下边的数学符号则使用双括号进行标注，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((&quot;$a&quot; &lt; &quot;$b&quot;))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git网络不好导致报错</title>
      <link href="/2019/08/23/git%E7%BD%91%E7%BB%9C%E4%B8%8D%E5%A5%BD%E5%AF%BC%E8%87%B4%E6%8A%A5%E9%94%99/"/>
      <url>/2019/08/23/git%E7%BD%91%E7%BB%9C%E4%B8%8D%E5%A5%BD%E5%AF%BC%E8%87%B4%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>校园网总是自带网速debuff，这就导致经常会在下载的时候中断，这个时候有几个常用的解决办法。</p><a id="more"></a><h1 id="修改缓冲区大小和超时时间（这个并没有明显的效果）"><a href="#修改缓冲区大小和超时时间（这个并没有明显的效果）" class="headerlink" title="修改缓冲区大小和超时时间（这个并没有明显的效果）"></a>修改缓冲区大小和超时时间（这个并没有明显的效果）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --gloab http.postBuffer 524288000 #gloab为全局设置</span><br><span class="line">git config --gloab http.lowspeedLimit 0</span><br><span class="line">git config --gloab http.lowspeedTime 999999</span><br></pre></td></tr></table></figure><h1 id="自动循环下载脚本"><a href="#自动循环下载脚本" class="headerlink" title="自动循环下载脚本"></a>自动循环下载脚本</h1><p>通过<code>shell</code>脚本实现自动断线重连</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#！ /bin/sh</span><br><span class="line">repo sync</span><br><span class="line">while[$? -ne 0] //$?为命令返回值，成功为0，失败为非0</span><br><span class="line">do              //具体在shell部分中进行讨论</span><br><span class="line">repo sync</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pkg-config的使用</title>
      <link href="/2019/08/18/pkg-config%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/08/18/pkg-config%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>pkg-config</code> 简单来说就是向用户向程序提供相应库的路径、版本号等信息的程序。</p><a id="more"></a><p>例如一下常用的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pkg-config --libs --cflags opencv</span><br><span class="line">$ pkg-config --libs --cflags gstreamer-1.0</span><br></pre></td></tr></table></figure><p>会显示一下信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-I/usr/include/opencv -lopencv_shape -lopencv_stitching -lopencv_superres -lopencv_videostab -lopencv_aruco -lopencv_bgsegm -lopencv_bioinspired -lopencv_ccalib -lopencv_datasets -lopencv_dpm -lopencv_face -lopencv_freetype -lopencv_fuzzy -lopencv_hdf -lopencv_line_descriptor -lopencv_optflow -lopencv_video -lopencv_plot -lopencv_reg -lopencv_saliency -lopencv_stereo -lopencv_structured_light -lopencv_phase_unwrapping -lopencv_rgbd -lopencv_viz -lopencv_surface_matching -lopencv_text -lopencv_ximgproc -lopencv_calib3d -lopencv_features2d -lopencv_flann -lopencv_xobjdetect -lopencv_objdetect -lopencv_ml -lopencv_xphoto -lopencv_highgui -lopencv_videoio -lopencv_imgcodecs -lopencv_photo -lopencv_imgproc -lopencv_core </span><br><span class="line"></span><br><span class="line">-I/usr/include/gstreamer-1.0 -I/usr/include/glib-2.0 -I/usr/lib/x86_64-linux-gnu/glib-2.0/include -pthread -lgstreamer-1.0 -lgobject-2.0 -lglib-2.0</span><br></pre></td></tr></table></figure><p>就是gcc在编译时需要的库路径<code>-l</code>与头文件路径<code>-I</code>，configure的作用也就是要检查你的包并提供信息给编译工具。<br>而以上的这些信息又是从哪里获取的呢？他是从包名为 <code>xxx.pc</code> 这个文件中找到的，比如以上的两条命令，他就是从<code>opencv.pc</code>、<code>gstreamer-1.0.pc</code>中找到的  </p><h2 id="pkg-config的工作方式"><a href="#pkg-config的工作方式" class="headerlink" title="pkg-config的工作方式"></a>pkg-config的工作方式</h2><p>缺省情况下，<code>pkg-config</code>首先在<code>prefix/lib/pkgconfig/</code>中查找相关包（譬如opencv）对应的相应的文件（opencv.pc）。在linux上上述路径名为 <code>/usr/lib/pkconfig/</code>。若是没有找到，它也会到<code>PKG_CONFIG_PATH</code>这个环境变量所指定的路径下去找。若是没有找到，它就会报错，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ pkg-config --libs --cflags gstreamer</span><br><span class="line">Package gstreamer was not found in the pkg-config search path.</span><br><span class="line">Perhaps you should add the directory containing `gstreamer.pc&apos;</span><br><span class="line">to the PKG_CONFIG_PATH environment variable</span><br><span class="line">Package &apos;gstreamer&apos;, required by &apos;world&apos;, not found</span><br></pre></td></tr></table></figure><p>设置环境变量PKG_CONFIG_PATH方法举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PKG_CONFIG_PATH=/opencv/lib:$PKG_CONFIG_PATH</span><br></pre></td></tr></table></figure><p>输出一个.pc文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat  /usr/lib/pkgconfig/libopenni.pc </span><br><span class="line">prefix=/usr</span><br><span class="line">exec_prefix=$&#123;prefix&#125;</span><br><span class="line">libdir=$&#123;exec_prefix&#125;/lib</span><br><span class="line">includedir=$&#123;prefix&#125;/include/ni</span><br><span class="line"></span><br><span class="line">Name: OpenNI</span><br><span class="line">Description: A general purpose driver for all OpenNI cameras.</span><br><span class="line">Version: 1.5.4.0</span><br><span class="line">Cflags: -I$&#123;includedir&#125;</span><br><span class="line">Libs: -L$&#123;libdir&#125; -lOpenNI</span><br></pre></td></tr></table></figure><p>可见.pc文件 是对其的库文件路径，头文件路径，版本号，Cflags等一些参数进行封装。  </p><p>同样也可以用一下方式对对应的库进行查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$  pkg-config opencv --libs --cflags</span><br><span class="line">-I/usr/include/opencv -lopencv_shape -lopencv_stitching -lopencv_superres -lopencv_videostab -lopencv_aruco -lopencv_bgsegm -lopencv_bioinspired -lopencv_ccalib -lopencv_datasets -lopencv_dpm -lopencv_face -lopencv_freetype -lopencv_fuzzy -lopencv_hdf -lopencv_line_descriptor -lopencv_optflow -lopencv_video -lopencv_plot -lopencv_reg -lopencv_saliency -lopencv_stereo -lopencv_structured_light -lopencv_phase_unwrapping -lopencv_rgbd -lopencv_viz -lopencv_surface_matching -lopencv_text -lopencv_ximgproc -lopencv_calib3d -lopencv_features2d -lopencv_flann -lopencv_xobjdetect -lopencv_objdetect -lopencv_ml -lopencv_xphoto -lopencv_highgui -lopencv_videoio -lopencv_imgcodecs -lopencv_photo -lopencv_imgproc -lopencv_core</span><br></pre></td></tr></table></figure><p>在具体的使用中可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc basic-tutorial-1.c -o basic-tutorial-1 `pkg-config --cflags --libs gstreamer-1.0`</span><br></pre></td></tr></table></figure><p>使用反引号将命令括起来，似乎使用<code>$()</code>也可以但是还没有试过，以后有机会再试。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记</title>
      <link href="/2019/08/17/Git/"/>
      <url>/2019/08/17/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git学习笔记"><a href="#Git学习笔记" class="headerlink" title="Git学习笔记"></a>Git学习笔记</h1><a id="more"></a><h2 id="获取与创建项目"><a href="#获取与创建项目" class="headerlink" title="获取与创建项目"></a>获取与创建项目</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>用 <code>git init</code> 在本地新建Git仓，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir new  </span><br><span class="line">$ cd new/  </span><br><span class="line">$ git init  </span><br><span class="line">Initialized empty Git repository in /home/qnb/new/.git/</span><br></pre></td></tr></table></figure><p>可以在这里看到生成的 <code>,git</code> 子目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qnb@qnb-pc:~/new$ ls -a</span><br><span class="line">.  ..  .git</span><br></pre></td></tr></table></figure><h3 id="Git-clone"><a href="#Git-clone" class="headerlink" title="Git clone"></a>Git clone</h3><p>从github上拉取项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone [url]</span><br></pre></td></tr></table></figure><hr><h2 id="基本快照（提交）"><a href="#基本快照（提交）" class="headerlink" title="基本快照（提交）"></a>基本快照（提交）</h2><h3 id="Git-add"><a href="#Git-add" class="headerlink" title="Git add"></a>Git add</h3><p><code>git add</code> 可以将文件添加到缓存，例如添加 <code>README</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch README</span><br><span class="line">$ git status -s #查看项目的当前状态</span><br><span class="line">?? README</span><br></pre></td></tr></table></figure><p>接下来使用 <code>git add</code>命令添加文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add README</span><br></pre></td></tr></table></figure><p>此时查看状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">A  README</span><br></pre></td></tr></table></figure><p>此时修改 <code>README</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo qnb &gt;&gt; README #覆盖写入是&gt;,结尾写入是&gt;&gt;  </span><br><span class="line">$ cat README</span><br><span class="line">qnb</span><br><span class="line">$ git status -s </span><br><span class="line">AM README</span><br></pre></td></tr></table></figure><p>其中 <code>AM</code> 状态是说明在将其添加入缓存之后又有改动，此时再次提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add README </span><br><span class="line">$ git status -s </span><br><span class="line">A  README</span><br></pre></td></tr></table></figure><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>显示 <strong><em>在上一次修改结束之后</em></strong> 是否有修改其中 <code>-s</code> 是为了显示简短输出，若不带参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status </span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   README</span><br></pre></td></tr></table></figure><p>输出较为完整</p><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>执行 <code>Git diff</code> 以获得更为详细的 <code>git status</code>信息<br><code>Git diff</code> 能显示已经写入缓存的数据与未写入缓存的数据之间的差异，主要的应用：  </p><ul><li>尚未缓存的改动（应该是尚未<code>add</code>的内容，但实际测试出现了所有的改动）：<code>add diff</code></li><li>查看已改动的缓存：<code>git diff --cached</code></li><li>查看已缓存的与未的缓存所有改动：<code>git diff HEAD</code></li><li>显示摘要而非整个diff：<code>git diff stat</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ echo QNB &gt;&gt; README </span><br><span class="line">$ cat README </span><br><span class="line">qnb</span><br><span class="line">qnb</span><br><span class="line">QNB</span><br><span class="line">$ git diff</span><br><span class="line">diff --git a/README b/README</span><br><span class="line">index 7a3b31e..bdbcbd0 100644</span><br><span class="line">--- a/README</span><br><span class="line">+++ b/README</span><br><span class="line">@@ -1 +1,3 @@</span><br><span class="line"> qnb</span><br><span class="line">+qnb</span><br><span class="line">+QNB</span><br><span class="line">$ git diff --cached</span><br><span class="line">diff --git a/README b/README</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..7a3b31e</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/README</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+qnb</span><br></pre></td></tr></table></figure></li></ul><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>将 <code>add</code> 到缓存区的修改 <code>commit</code> 到仓库中<br><code>Git</code> 为你的每一个提交都记录你的名字与电子邮箱地址，故而需要登记邮箱和用户名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &apos;qnb&apos;</span><br><span class="line">$ git config --global user.email ‘emil@qq.com’</span><br></pre></td></tr></table></figure><p>在<code>git log</code>中有一项是<code>Author</code>，你设置的名字与电子邮箱就会在这里显示。  </p><img src="/2019/08/17/Git/commit.jpg" title="git_log"><p>接下来进行提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;第一次提交&apos; # -m 选项进行添加注释</span><br><span class="line">[master (root-commit) 94b92eb] 第一次提交</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure><p>此时，显示为上一次修改之后没有修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   README</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><h3 id="git-reset-HEAD"><a href="#git-reset-HEAD" class="headerlink" title="git reset HEAD"></a>git reset HEAD</h3><p>用于取消已缓存的内容（add的内容），例如：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD README </span><br><span class="line">$ echo 测试修改撤销 &gt;&gt; README </span><br><span class="line">$ cat README </span><br><span class="line">qnb</span><br><span class="line">qnb</span><br><span class="line">QNB</span><br><span class="line">测试修改撤销</span><br><span class="line">$ git add README </span><br><span class="line">$ git status -s</span><br><span class="line">M  README</span><br><span class="line">$ git reset HEAD README</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       README</span><br><span class="line">$ git status -s</span><br><span class="line"> &lt;font color=#FF0000 face=&quot;黑体&quot;&gt;M&lt;/font&gt; README</span><br></pre></td></tr></table></figure><p>此时提交将不提交 <code>README</code> ，如果仍要提交可以使用 <code>-am</code> 参数进行 <code>commit</code>  </p><h3 id="移除与移动"><a href="#移除与移动" class="headerlink" title="移除与移动"></a>移除与移动</h3><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，此时使用<code>rm</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -rf &lt;file&gt; # 参数r为递归，f为提高权限，和系统的rm同理</span><br></pre></td></tr></table></figure><p>也可以不删除工作区文件，只取消对他的跟踪（删除在缓存里的文件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm --cached README</span><br></pre></td></tr></table></figure><p><code>mv</code>功能类似，不做叙述</p><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><ul><li><p>查看最新的版本库里和工作区里对应文件的差异  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD -- filename</span><br></pre></td></tr></table></figure></li><li><p>回退到指定版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git log #查看版本信息</span><br><span class="line">$ git reset --hard commit_id # commit_id 查询到的版本号</span><br></pre></td></tr></table></figure></li><li><p>创建本地分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch localbranchname</span><br></pre></td></tr></table></figure></li><li><p>切换本地分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout branchname # checkout -b 进行创建之后再切换</span><br></pre></td></tr></table></figure></li><li><p>由远程仓创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b localbranchname origin/remotebranchname #-b创建本地分支之后切换到对应的远程分支</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git分支保存hexo博客源码</title>
      <link href="/2019/08/15/Git%E5%88%86%E6%94%AF%E4%BF%9D%E5%AD%98hexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81/"/>
      <url>/2019/08/15/Git%E5%88%86%E6%94%AF%E4%BF%9D%E5%AD%98hexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于hexo生成的静态资源要求保存在github的master分支上，那么源代码如果再开启一个仓存储就会很麻烦，所以如果使用分支 <code>branch</code> 将源代码和和静态资源保存在同一个仓中就会很方便。</p><a id="more"></a><h1 id="新建一个本地仓并推送到github分支"><a href="#新建一个本地仓并推送到github分支" class="headerlink" title="新建一个本地仓并推送到github分支"></a>新建一个本地仓并推送到github分支</h1><p>初始化完一个hexo目录之后（假如为HEXO）：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd HEXO</span><br><span class="line">$ git init # 初始化本地仓</span><br><span class="line">$ git remote add origin git@github.com:username/username.github.io.git#关联远程服务器</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;blog&quot;</span><br><span class="line">$ git push origin master:remotebranch # remotebranch为远程仓的分支名，例如hexo</span><br></pre></td></tr></table></figure><p>远程仓中就会有一个新的分支，备份工作完成  </p><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>之后再做修改可以在github的 <code>repository setting</code> 中设置默认分支为hexo源码的分支，因为主要关心的也是hexo源码，设置好之后再次修改可以直接git，操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:qm-k/qm-k.github.io.git</span><br><span class="line">$ git branch -a #查看分支信息</span><br><span class="line">$ git checkout -b hexo origin/hexo #如果不在源码分支，则进行切换，同时创建本地hexo分支</span><br><span class="line">$ npm install hexo //win10装完的时候，power shell无法识别可以再尝试npm install -g hexo-cli  </span><br><span class="line">//-g为全局生效，直接安装在系统中</span><br><span class="line">$ hexo init </span><br><span class="line">$ npm install</span><br><span class="line">$ npm install hexo-deployer-git //快捷部署到git插件</span><br><span class="line"></span><br><span class="line">$ npm install hexo-generator-search --save //本地搜索插件  </span><br><span class="line"></span><br><span class="line">$ npm install --save hexo-pdf //上传pdf插件</span><br><span class="line"></span><br><span class="line">$ npm install hexo-neat --save //压缩博客插件  </span><br><span class="line"></span><br><span class="line">$ npm install hexo-math --save  //数学公式插件</span><br></pre></td></tr></table></figure><pre><code>PS: nodejs是可以直接是用apt安装的，如果是win10则可以直接在官网下载安装包在安装过程中选中x86_64即可。hexo-cli和hexo是不同的，他是一个命令行工具，用以初始化，例如init，而hexo则用以支持在初始化完成之后的工作。只要保证git和nodejs存在，以上步骤就可以完成</code></pre><p>至此迁移工作完成可以进行部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean #如果出错进行清除尝试</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo s --debughexo server -p 5000 #本地显示，正常为4000端口，如果占用可以用5000</span><br><span class="line">$ hexo d #确认无误可以部署</span><br></pre></td></tr></table></figure><p>可以将源码分支设为默认分支，这样可以方便在clone下来之后直接进行编辑，同时推送保存可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin HEXO:HEXO #(本地分支):(远程分支)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo添加标签和分类</title>
      <link href="/2019/08/15/hexo%E6%B7%BB%E5%8A%A0%E6%A0%87%E7%AD%BE%E5%92%8C%E5%88%86%E7%B1%BB/"/>
      <url>/2019/08/15/hexo%E6%B7%BB%E5%8A%A0%E6%A0%87%E7%AD%BE%E5%92%8C%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在我们的博客文章多了以后，需要对其进行归类以方便查找，hexo提供“分类”和“标签”用于文章的归类管理。一下记录如何在hexo框架下添加标签和分类。  </p><a id="more"></a><p>最终效果如下所示：  </p><p>标签效果：  </p><img src="/2019/08/15/hexo添加标签和分类/tags.jpg">   <p>分类效果：  </p><img src="/2019/08/15/hexo添加标签和分类/fenlei.jpg"> <h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul><li>修改配置文件<br>首先打开 <code>theme/next/_config.yml</code>，找到如下配置，删除”categories”和“tags”前的注释符#。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line"></span><br><span class="line">  essay: /categories/随笔 || align-left # 博客首页展示文本/访问路径/自定义归档名称 || 对应的图标</span><br></pre></td></tr></table></figure></li></ul><h2 id="如果想给标签加图标"><a href="#如果想给标签加图标" class="headerlink" title="如果想给标签加图标"></a>如果想给标签加图标</h2><p>图标名称来自于 <a href="https://fontawesome.com/icons?d=gallery" target="_blank" rel="noopener">FontAwesome icon</a><br>保存并关闭文件。</p><ul><li>生成页面<br>此时通过<code>hexo s</code>可以在主页看到这两个导航，但是点进去后会得到 Cannot GET /tags/ 或Cannot GET /categories/的页面，需要分别为其创建相应的页面。  </li></ul><p>进入博客根目录执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo create page tags</span><br><span class="line">$ hexo create page categories</span><br></pre></td></tr></table></figure><p>成功后提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INFO  Created: ~/Documents/blog/source/tags/index.md</span><br><span class="line">INFO  Created: ~/Documents/blog/source/categories/index.md</span><br></pre></td></tr></table></figure><p>分别打开这两个index.md的文件，修改其内容。</p><p>tags/index.md  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-12-01 01:12:43</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>categories/index.md  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2018-12-01 00:52:39</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>保存以后就能成功生成这两个页面。</p><h1 id="给文章加上分类和标签"><a href="#给文章加上分类和标签" class="headerlink" title="给文章加上分类和标签"></a>给文章加上分类和标签</h1><p>上述步骤仅仅是生成了分类和标签的导航栏，实际的分类或标签条目需要在文章中添加才行，打开要分类的文章，在文件头添加“tags”标签或“categories”进行分类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">title: hexo 添加标签和分类 </span><br><span class="line">date: 2018-12-01 01:06:34</span><br><span class="line">categories: </span><br><span class="line">- hexo</span><br><span class="line">- config</span><br><span class="line">- tags</span><br><span class="line">tags:</span><br><span class="line">- hexo</span><br><span class="line">- tags</span><br></pre></td></tr></table></figure><p>添加“- xxx”作为categories或tags的条目，在“tags”下添加多个条目表示给文章打了多个标签；而如果在“categories”下增加多个条目，则是一个嵌套的结构，例如上述配置会产生如下效果：  </p><img src="/2019/08/15/hexo添加标签和分类/hexo_categories.jpg"><h1 id="部署生效"><a href="#部署生效" class="headerlink" title="部署生效"></a>部署生效</h1><p>完成以上所有之后就可一看到效果了。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean #可以不clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo s --debughexo server -p 5000 #本地显示，正常为4000端口，如果占用可以用5000</span><br><span class="line">$ hexo d #确认无误可以部署</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/front-matter</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/08/14/hello-world/"/>
      <url>/2019/08/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome </p><p>More info: <a href="https://github.com/qm-k" target="_blank" rel="noopener">github</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
